<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Luigi Colella RSS Feed]]></title><description><![CDATA[マルタ島は最高]]></description><link>https://dondakeshimo.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Mon, 26 Jul 2021 15:44:34 GMT</lastBuildDate><item><title><![CDATA[GoでCLIのTODOリストを作成した時の振り返り]]></title><description><![CDATA[todo-cliを開発する上で良かった点などの振り返り]]></description><link>https://dondakeshimo.github.io/tech-blog/blog/how-to-develop-toco-cli</link><guid isPermaLink="false">https://dondakeshimo.github.ioblog/how-to-develop-toco-cliGoでCLIのTODOリストを作成した時の振り返り</guid><dc:creator><![CDATA[dondakeshimo]]></dc:creator><pubDate>Fri, 23 Jul 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;目次 &lt;!-- exclude-toc --&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec1-0-0&quot;&gt;開発管理や開発ルール&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-1-0&quot;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-2-0&quot;&gt;GitHub Flow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-3-0&quot;&gt;GitHub Projects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-4-0&quot;&gt;英語&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-5-0&quot;&gt;CI/CD GitHub Actions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec2-0-0&quot;&gt;設計&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-1-0&quot;&gt;ディレクトリ構造&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-2-0&quot;&gt;クリーンアーキテクチャ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-3-0&quot;&gt;テスト&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec3-0-0&quot;&gt;コーディング&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-1-0&quot;&gt;Makefile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-2-0&quot;&gt;Value Object&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-3-0&quot;&gt;GoDoc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-4-0&quot;&gt;Table Driven Test&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-5-0&quot;&gt;ライブラリ選定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-5-1&quot;&gt;CLIフレームワーク cobra vs urfave/cli&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-5-2&quot;&gt;writerライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-6-0&quot;&gt;golangci-lint&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-7-0&quot;&gt;ポインタ vs 値&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-8-0&quot;&gt;スケジューリング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-8-1&quot;&gt;launchd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-8-2&quot;&gt;cron&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-9-0&quot;&gt;通知方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-9-1&quot;&gt;ossascript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-9-2&quot;&gt;slack&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec4-0-0&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CLIでのTODO管理ツールをGoで実装しました。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dondakeshimo.github.io/tech-blog/blog/introduce-todo-cli/&quot;&gt;https://dondakeshimo.github.io/tech-blog/blog/introduce-todo-cli/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dondakeshimo/todo-cli&quot;&gt;https://github.com/dondakeshimo/todo-cli&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;その際に得た知見ややっていて良かったこと、やって失敗だったと思うことなどを振り返っていこうと思います。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;開発管理や開発ルール&lt;/h1&gt;
&lt;p&gt;&lt;a id=&quot;sec1-1-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;GitHub&lt;/h2&gt;
&lt;p&gt;デファクトスタンダードなので特に説明することもないかもしれませんが、GitHubを用いてコード管理を行いました。
コード管理だけではなく、後述するようにCI/CDやプロジェクト管理もGitHubで完結させました。&lt;/p&gt;
&lt;p&gt;(最近知ったのですがGitLabってオンプレ以外に普通のWebアプリケーションも提供されているんですね。
特に比較とかはしていないです。)&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-2-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;GitHub Flow&lt;/h2&gt;
&lt;p&gt;ブランチ戦略というものがあります。
よく知られているものとしてGit FlowとGitHub Flowがあります。
私はGitHub Flowしか利用したことがないので、Git Flowの詳細は他サイトに譲ります&lt;a href=&quot;https://www.atlassian.com/ja/git/tutorials/comparing-workflows/gitflow-workflow&quot;&gt;(参考)&lt;/a&gt;。
GitHub Flowを要約すると変更をmasterに反映するときはPR経由で行えよ、ということになります。
GitHub Flowに準じた開発を行うと決めたので、個人開発ではありますが、masterに直接マージするようなことはせずにPRを毎回作成して開発を行いました。&lt;/p&gt;
&lt;p&gt;良かった点は&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;masterは常にテストが通った状態になる&lt;/li&gt;
&lt;li&gt;管理しているチケットと紐付けができる&lt;/li&gt;
&lt;li&gt;行った変更を自分で追いやすくなる&lt;/li&gt;
&lt;li&gt;作業の中断ステータスがわかりやすい&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;悪かった点は&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;単純に面倒臭い&lt;/li&gt;
&lt;li&gt;個人リポジトリだとmasterへのpush禁止をGitHubがしてくれないので2, 3回 masterにpushしてしまった&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;次回個人開発を行うことがあれば、最初はmaster pushで整えて&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;test&lt;/li&gt;
&lt;li&gt;CI/CD パイプライン&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;が整ったタイミングでPRを出すようにしようかと思います。
ただ、後で反省するように上記二つともプロジェクトの最初期に整えるべきものだと考えているので、実質最初からPRを出すつもりです。&lt;/p&gt;
&lt;p&gt;また、masterへのpush防止策としてはgit hookに何かしら突っ込んでおく必要があるかなと思っています。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-3-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;GitHub Projects&lt;/h2&gt;
&lt;p&gt;プロジェクト管理は GitHub Projectsを利用しました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dondakeshimo/todo-cli/projects/1&quot;&gt;https://github.com/dondakeshimo/todo-cli/projects/1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dondakeshimo/todo-cli/projects/2&quot;&gt;https://github.com/dondakeshimo/todo-cli/projects/2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;欲しい機能は最初からほとんど決まっていたので、メモ書き以下の要件を最初に記載していたようです。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dondakeshimo/todo-cli/issues/1&quot;&gt;https://github.com/dondakeshimo/todo-cli/issues/1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;IssueとPRは紐付けができるので機能の作成さえしておけば、Kanbanでの移動はそこまで必要ないです。
調査系のタスクが入った時にIssueがあると自分の進捗がわかりやすいのとドキュメントが勝手に出来上がっていくのでとても良かったです。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dondakeshimo/todo-cli/issues/33&quot;&gt;https://github.com/dondakeshimo/todo-cli/issues/33&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;メリットはやはりコード管理ツールと統合されていることに尽きると思います。今後もGitHubで何かしらのプロジェクトを行うときは重宝すると思います。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-4-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;英語&lt;/h2&gt;
&lt;p&gt;コードのコメントや使い方などは全て英語にしようと決めていました。
英語の勉強をしたかったという部分と、日本語が入ったコードはダサいと思ったのと、ゆくゆくは外国の方にもcommitしてもらえるようなプロダクトにしたいという野望があったからです。&lt;/p&gt;
&lt;p&gt;2人の知人にcontributerをしていただいたのですが、その際にPRを英語で出していただいてハッとさせられました。
海外の方にcommitしてもらうためにはIssueやPRも全て英語で行う必要があったのでは？？と。
ちょっとそこまで英語にリソース割けないなと思い妥協しています。個人リポジトリですしね...&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-5-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;CI/CD GitHub Actions&lt;/h2&gt;
&lt;p&gt;CI/CDツールとしてはGitHub Actionsを使用しました。
ツールで行いたかったことは下記になります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;PRに対して&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;コードフォーマットのチェック&lt;/li&gt;
&lt;li&gt;test&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;master commitに対して&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;バイナリのビルド&lt;/li&gt;
&lt;li&gt;Releasesの作成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;コードフォーマットのチェックやtestは比較的簡単に設定できました &lt;a href=&quot;https://github.com/dondakeshimo/todo-cli/blob/master/.github/workflows/go.yml&quot;&gt;(設定ファイル)&lt;/a&gt;。
Releasesの作成についてはそれなりに苦闘したので、&lt;a href=&quot;https://dondakeshimo.github.io/tech-blog/blog/github-actions-changelog/&quot;&gt;別記事&lt;/a&gt;にまとめています。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;設計&lt;/h1&gt;
&lt;p&gt;&lt;a id=&quot;sec2-1-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;ディレクトリ構造&lt;/h2&gt;
&lt;p&gt;ディレクトリ構造について初期は &lt;a href=&quot;https://github.com/golang-standards/project-layout&quot;&gt;golang-standards/project-layout&lt;/a&gt; を模倣して設計していました。
ところが、 &lt;a href=&quot;https://github.com/golang-standards/project-layout/issues/117&quot;&gt;this is not a stndard Go project layout&lt;/a&gt; というIssueがGo開発者から立てられ、これは標準ではないし、Goの思想としては標準レイアウトのようなものは存在しない、なんでも好きなように作れば良いのだよということが公言されていました。
特に問題となっていたのは &lt;code class=&quot;language-text&quot;&gt;pkg&lt;/code&gt; ディレクトリのようで、慣例として作られていた &lt;code class=&quot;language-text&quot;&gt;vendor&lt;/code&gt; との差分がよくわからないなどの意見が見られました。思考停止で利用していましたが、このIssueを受けて &lt;code class=&quot;language-text&quot;&gt;internal&lt;/code&gt; ディレクトリは &lt;code class=&quot;language-text&quot;&gt;pkg&lt;/code&gt; ディレクトリに&lt;a href=&quot;https://github.com/dondakeshimo/todo-cli/pull/78&quot;&gt;まとめました&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;結果的には以下のような構成にしました。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;.
├── Makefile
├── README.md
├── cmd
│   └── todo
│       └── main.go
├── go.mod
├── go.sum
├── pkg
│   ├── commands
│   ├── domain
│   │   ├── notifier
│   │   ├── scheduler
│   │   └── task
│   ├── gateways
│   │   └── json
│   └── usecases
├── scripts
│   └── uninstall.sh
└── test
    └── scenario
        └── crud_test.go&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;pkg&lt;/code&gt; の中のディレクトリはそのままパッケージ名となります。
こちらは次節にて詳しく述べる予定ですが、クリーンアーキテクチャのレイヤ名を随所に使用しています。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-2-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;クリーンアーキテクチャ&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://dondakeshimo.github.io/tech-blog/blog/clean-architecture-uncle-bob/&quot;&gt;https://dondakeshimo.github.io/tech-blog/blog/clean-architecture-uncle-bob/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;にてまとめているクリーンアーキテクチャを念頭に設計しています。というよりは開発していくうちにクリーンアーキテクチャっぽく修正していきました。&lt;/p&gt;
&lt;p&gt;CLIフレームワークを変更したタイミングがあったのですが、CLIフレームワークとアプリケーションルールがそのタイミングでは絡み付いており、変更が非常に重たいタスクになってしまいました。これを嫌って、先にusecase層とcontroller層(commandsディレクトリ)を分割しました。これによってフレームワークに依存しているのはcontroller層のみとなり変更を容易に行うことができました。(分割は簡単ではなかったです。)&lt;/p&gt;
&lt;p&gt;このことから、これからはフレームワークやインプットアウトプットが少しでも変わる可能性がある場合は常にクリーンアーキテクチャを最初から意識して設計していこうと心に誓いました。&lt;/p&gt;
&lt;p&gt;逆にクリーンアーキテクチャを意識したアーキテクチャになっていた部分で良かったのは、後述するスケジューリングや通知の詳細実装を追加していくのが非常に容易だったことです。最初にインタフェースを決めておく難易度はありましたが、今回の場合は最初から要件がある程度固まっていたのでそこまで悩まずに済みました。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-3-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;テスト&lt;/h2&gt;
&lt;p&gt;今回の場合二つのテストが必要と考えていました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;domain/taskの単体テスト&lt;/li&gt;
&lt;li&gt;e2eテスト&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;逆にそれ以外の部分は手を抜いています。
ただし、結構アプリケーションロジックにバグが紛れたりするので、usecase層もテストするべきだったなと思っています。
これは今後追加するかもしれません。&lt;/p&gt;
&lt;p&gt;最初にテストスコープを決めていて良かったのはdomain層に入れるべきものがはっきりとしたことです。
このロジックにはテスト必要そうだぞというものは大抵domain層にいるべきものなので、ビジネスロジックがusecaseに紛れ込むのを防ぐことができました。&lt;/p&gt;
&lt;p&gt;テストの実装時期ですが、プロトタイプのタイミングから単体テストは実装しておくべきだと感じました。
後からやるのは辛いというのが主な理由ですが、先述の通りテストを念頭においた実装をすることでかなりすっきりとした設計になりがちですなので、気づいたらスパゲッティを錬成していたということを防ぐためにも最初からテストを書くべきです。&lt;/p&gt;
&lt;p&gt;逆にe2eテストについてはある程度までは放置しておいて良いと感じました。
テスト項目だけ決めておいて毎回手作業で確認していくくらいで良いかなと。
結構テストの実装自体が手間ですし、その手間をかけて自動化するならまずは満足できるレベルのプロダクトを作るのが先だろというのが今の思いです。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;コーディング&lt;/h1&gt;
&lt;p&gt;&lt;a id=&quot;sec3-1-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Makefile&lt;/h2&gt;
&lt;p&gt;Makefileは最初に用意しておくと良いと思います。GoのMakefileは毎回ほとんど同じものになると思うので、ここに自分が使っているものでテンプレとなりそうな部分を貼っておきます。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;GOBUILD=go build
GOCLEAN=go clean
GOTEST=go test
GOGET=go get
GOFMT=gofmt
GOGEN=go generate
GOIMPORTS=goimports
GOLINT=golangci-lint
BINARY_NAME=todo
CMD_PKG=./cmd/todo
SCENARIO_DIR=./test/scenario

all: help

.PHONY: init
init: ## initilize developer environment
  # mockを利用する場合
	go install github.com/golang/mock/mockgen@latest

.PHONY: get
get: ## go get dependencies
	$(GOGET) -u -v -t -d ./...

.PHONY: build
build: ## build go binary
	$(GOBUILD) -o $(BINARY_NAME) -v $(CMD_PKG)

.PHONY: mockgen
mockgen: ## generate mock
	$(GOGEN) ./...

.PHONY: test
test: build ## go test
	$(GOTEST) -v ./...

.PHONY: scenario-test
scenario-test: build ## run scenario test
	$(GOTEST) -v $(SCENARIO_DIR) -tags scenario

.PHONY: clean
clean: ## remove go binary
	$(GOCLEAN)
	rm -f $(BINARY_NAME)

.PHONY: fmt
fmt: ## format go files
	$(GOFMT) -l -w -s .
	$(GOIMPORTS) -w .

.PHONY: lint
# need docker to run this command
# this command just run golangci-lint
# so, if you hate docker, you can run equivalent this installing golangci-lint locally
lint: ## check lint, format
	docker run --rm -v $(shell pwd):/app -w /app golangci/golangci-lint:v1.41.0 golangci-lint run -v

.PHONY: help
help: ## DIsplay this help screen
	@grep -E &amp;#39;^[a-zA-Z_-]+:.*?## .*$$&amp;#39; $(MAKEFILE_LIST) | awk &amp;#39;BEGIN {FS = &amp;quot;:.*?## &amp;quot;}; {printf &amp;quot;\033[36m%-20s\033[0m %s\n&amp;quot;, $$1, $$2}&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;プロジェクトの最初期から置いておくと良いと思います。最初期は &lt;code class=&quot;language-text&quot;&gt;go run&lt;/code&gt; とかを結局たくさん使いますが...&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-2-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Value Object&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://dondakeshimo.github.io/tech-blog/blog/evans-eric-ddd/&quot;&gt;https://dondakeshimo.github.io/tech-blog/blog/evans-eric-ddd/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;で説明している値オブジェクトを利用できる場面では利用することを意識しました。
具体的にはタスクに紐付けられる時間などが値オブジェクトとして定義されています。&lt;/p&gt;
&lt;p&gt;時間については基本的にただの文字列なのですが、値オブジェクトとすることで文字が時間を表現するのに有効かどうかや、時間としての加算減算に対応できるようになっています。ビルドに通ればランタイムでのエラーがほとんど起きなくなったので、値オブジェクトは利用できるシーンでは積極的に利用すべきだと感じています。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-3-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;GoDoc&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://qiita.com/shibukawa/items/8c70fdd1972fad76a5ce&quot;&gt;チョットできるGoプログラマーになるための詳細GoDoc&lt;/a&gt; で詳細に述べられていますが、Goではドキュメント自動生成のためのコメントお作法があります。このお作法の通りにコメントを書けばIDEがメソッドの説明とかを出して来れたりします。&lt;/p&gt;
&lt;p&gt;コードは大体最初に思い描いたものよりも長く、複雑になるので最初からGoDocを書くことを忘れずにしておくと、エディタの力を最大限に生かすことができます。(ただ本当に面倒くさい)。次回以降もちゃんと書けるかは心の余裕によると思います。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-4-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Table Driven Test&lt;/h2&gt;
&lt;p&gt;Table Driven Testをご存知でしょうか？
テストの可読性が飛躍的に向上し、DRYなテストを実現できる手法になります。
自分が参考にしたサイトを見つけることができなかったので、お好きなサイトをGoogle先生の書庫から選んで参照いただければと思います。&lt;/p&gt;
&lt;p&gt;これを知って実装できたことでテストがかなり書きやすかったのでここで取り上げています。
しばらくはTable Driven Testを使ってテストを書き続けるでしょう。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-5-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;ライブラリ選定&lt;/h2&gt;
&lt;p&gt;ライブラリの選定はしっかりとするべきだという話です。&lt;/p&gt;
&lt;p&gt;ライブラリを利用するということは依存が一つ増えるということです。
依存が一つ増えたらメンテナンスのための改修が必要になるリスクが一つ増えるということです。
まずはライブラリを使うか自前で実装するべきかという部分を真剣に考えた方が良いというのが最近の考えです。&lt;/p&gt;
&lt;p&gt;ライブラリを選定するタイミングで確認するべきは&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Star数&lt;/li&gt;
&lt;li&gt;最終更新日&lt;/li&gt;
&lt;li&gt;更新頻度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;あたりだと考えていますが、実際に使ってみないとわからない部分も多々あると思うので参考程度に。&lt;/p&gt;
&lt;p&gt;todo-cliではtodoリストの表示と、CLIフレームワークにおいて外部ライブラリを使用しています。
それぞれについて少し解説します。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-5-1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;CLIフレームワーク cobra vs urfave/cli&lt;/h3&gt;
&lt;p&gt;初期段階では &lt;a href=&quot;https://github.com/urfave/cli&quot;&gt;urfave/cli&lt;/a&gt; を利用していました。
最初からcobraも選択肢には入っていたのですが、同等の人気である urfave/cliが先に検索にヒットしたのでなんとなくで使っていました。&lt;/p&gt;
&lt;p&gt;結果としては&lt;a href=&quot;https://github.com/spf13/cobra&quot;&gt;cobra&lt;/a&gt;に途中で乗り換えており、これからもCLIフレームワークを利用するならcobra一択だろうと考えています。&lt;/p&gt;
&lt;p&gt;urfave/cliのよくない点は大きく二つです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/campuscodi/status/1371227524127199241?s=19&quot;&gt;twitter&lt;/a&gt; で指摘されているが、謎の情報を送る処理が実装されていた&lt;/li&gt;
&lt;li&gt;必ず &lt;code class=&quot;language-text&quot;&gt;todo [option] [args]&lt;/code&gt; の順番でコマンドを叩く必要があり、タスクの内容の後にオプションをつけるといったことができなかった&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;その他にも細かい点でcobraの方が気が利いている部分が多く、紹介記事やStar数だけでは実際の使用感は判断できないのだなと感じました。
このことから私が得られる教訓は、導入ハードルを恐れずにどんどん知らないツールを触っていけ、ということです。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-5-2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;writerライブラリ&lt;/h3&gt;
&lt;p&gt;初期段階ではGoの標準パッケージにある &lt;a href=&quot;https://pkg.go.dev/text/tabwriter&quot;&gt;tabwriter&lt;/a&gt; を利用していました。
表示がリッチである必要はないと考えていたので、これで十分と考えていたのですが、知人が触って来れている時に日本語で表記がずれるという課題を共有いただき更に解決策となるパッケージもご提示していただきました。&lt;/p&gt;
&lt;p&gt;途中で乗り換えたライブラリが &lt;a href=&quot;https://github.com/olekukonko/tablewriter&quot;&gt;tablewriter&lt;/a&gt; になります。 CJKに対応しており、リッチな表を書くこともできます。&lt;/p&gt;
&lt;p&gt;表示系のライブラリではCJK(China, Japan, Korea)言語に対応しているかどうかを気にかける必要があるのだということを学べました。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-6-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;golangci-lint&lt;/h2&gt;
&lt;p&gt;Goのフォーマッターやリンターは複数のパッケージ、ツールに別れておりそれを統合したツールもいくつかありますが、自分が調べた範囲で2021/07時点では &lt;a href=&quot;https://github.com/golangci/golangci-lint&quot;&gt;golangci-lint&lt;/a&gt; を用いるのが良さそうだと感じました。
使い方等はREADMEや紹介記事も多数あるのでここでは省略します。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-7-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;ポインタ vs 値&lt;/h2&gt;
&lt;p&gt;(この節の内容はうろ覚えなので100%信用しないでください。)&lt;/p&gt;
&lt;p&gt;Goではポインタがヒープ領域に割り当てられます。
そのため、軽量な値に関してはポインタでの受け渡しよりも値渡しを行った方が良いです。
具体的にはプリミティブ型で関数内で値を変更しない場合は値渡しで良いと言えると思います。&lt;/p&gt;
&lt;p&gt;これはメソッドのレシーバにも同様のことが言えます。
軽量な構造体に対するメソッドの場合はポインタを指定するよりも値を渡した方が早くなります。&lt;/p&gt;
&lt;p&gt;また、ポインタの利用を消極的にすることで関数型言語のように副作用のない(少ない)関数を書くことが意識できます。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-8-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;スケジューリング&lt;/h2&gt;
&lt;p&gt;この節ではスケジューリング機能をどのように実装したかを説明します。&lt;/p&gt;
&lt;p&gt;スケジューリング機能とググると &lt;a href=&quot;https://github.com/robfig/cron&quot;&gt;robfig/cron&lt;/a&gt; がヒットするのではないかと思います。
当然の話ではありますが、スケジューリングを行うプログラムはプロセスとして常駐する必要があります。
Goのみでこれを行おうとすると、プロセスを走り続ける必要があり軽さや使いやすさという点で疑問が生じる設計しか思いつきませんでした。&lt;/p&gt;
&lt;p&gt;よって、基本戦略としてはOSに備わったスケジューリング機能を使用する方針としています。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-8-1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;launchd&lt;/h3&gt;
&lt;p&gt;MacOSではcronを使用するのは非推奨とされており、代わりにLauncdというプロセスをスケジューラとして利用するように言われています。
&lt;a href=&quot;https://qiita.com/rsahara/items/7d37a4cb6c73329d4683&quot;&gt;launchdで定期的にスクリプトを実行&lt;/a&gt; にて詳細に開設されているので、利用に際して困るというようなことはなかったです。
指定箇所に指定フォーマットのXMLファイルを配置するだけなので実装難易度もそこまで高くないです。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-8-2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;cron&lt;/h3&gt;
&lt;p&gt;Linuxではcronがおおよそインストールされていると信じてcronを用いたスケジューリングもできるようにしました。&lt;/p&gt;
&lt;p&gt;こちらについてはタスクの登録方法が複数あるのですが、課題となったのは権限です。
launchdと同様の方針で、cronファイルを &lt;code class=&quot;language-text&quot;&gt;/etc/cron.d&lt;/code&gt; に配置するだけで済むと考えていたのですが、配置するためにはroot権限が必要であり、またcronファイルもroot権限である必要があることがわかりました。
root権限をアプリケーションに与える方針はユーザビリティやセキュリティの観点でありえない選択肢であると感じたので、ファイルを配置する方針は諦めました。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dondakeshimo.github.io/tech-blog/blog/how-to-use-cron/&quot;&gt;諸々調べた結果&lt;/a&gt; もまとめてあるので見ていただければと思いますが、結局 &lt;code class=&quot;language-text&quot;&gt;crontab [file]&lt;/code&gt; でスケジュール登録する方針としました。&lt;/p&gt;
&lt;p&gt;しかし、こちらの方針にも問題点があり、指定したcronファイルで全てのジョブが上書きされてしまうのです。そのため、ユーザがもともとcrontabを使用していた場合は利用するべきではないですし、自分の登録したジョブも注意を払わなければ最新の一件しかスケジュール登録されないということになってしまいます。詳細な実装についてはリポジトリの方を参照いただければと思います。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-9-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;通知方法&lt;/h2&gt;
&lt;p&gt;理想はポップアップを出すことだと考えていました。MacにおいてはシンプルにポップアップをCLIから呼び出すインタフェースが搭載されており、容易に実装することができましたが、linuxについてのポップアップはまだ特に考えられていないです。Slackに投げられればそれで良いだろうと甘えました。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-9-1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;ossascript&lt;/h3&gt;
&lt;p&gt;遊んでもらえれば楽しいと思うのですが、&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;osascript -e &amp;#39;display notification &amp;quot;通知したいメッセージ&amp;quot;&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;とターミナルで打っていただければ通知センターにメッセージが届きます。
似たような方法で、&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_cmds.html#//apple_ref/doc/uid/TP40000983-CH216-SW12&quot;&gt;色々な制御ができる&lt;/a&gt; のでこれらを用いてポップアップ通知を実現しています。&lt;/p&gt;
&lt;p&gt;実装としては &lt;code class=&quot;language-text&quot;&gt;os/exec&lt;/code&gt; によって外部コマンドを呼び出す形になっています。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-9-2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;slack&lt;/h3&gt;
&lt;p&gt;SlackではIncomming Webhookを利用すればHTTP POSTリクエストを送ることでメッセージを送信することができます。
Incoming Webhookの導入はユーザに委ねるしかありませんが、その他の解決策もないと思ったので妥協しました。
LINEラブな方のためにLINE Botインタフェースを用意するとかも面白そうではありますね。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec4-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;まとめ&lt;/h1&gt;
&lt;p&gt;GoでCLIを作るのは非常に楽しかったです。cobraというフレームワークが最高です。kubectlとかを参考にできたところも良かったですね。
開発途中でドメイン駆動設計やクリーンアーキテクチャについて勉強していたので、プロトタイプからどんどん設計周りの改善案が出てきたというのも面白かったポイントです。&lt;/p&gt;
&lt;p&gt;今後も開発は続けますし、よければ追加機能や機能修正のPRをお待ちしています。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[CLIでTODO管理を行うツールを作ったので紹介させてください]]></title><description><![CDATA[TODO管理ツールを作ったのでみんなに使って欲しいです]]></description><link>https://dondakeshimo.github.io/tech-blog/blog/introduce-todo-cli</link><guid isPermaLink="false">https://dondakeshimo.github.ioblog/introduce-todo-cliCLIでTODO管理を行うツールを作ったので紹介させてください</guid><dc:creator><![CDATA[dondakeshimo]]></dc:creator><pubDate>Fri, 23 Jul 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;目次 &lt;!-- exclude-toc --&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec1-0-0&quot;&gt;TODO管理ツールを作りました&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-1-0&quot;&gt;TODO管理はCLIでやりたい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-2-0&quot;&gt;リマインダー機能が欲しい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-3-0&quot;&gt;必要十分な機能が欲しい&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec2-0-0&quot;&gt;インストール方法&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-1-0&quot;&gt;Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-2-0&quot;&gt;バイナリのダウンロード&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec3-0-0&quot;&gt;使い方&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-1-0&quot;&gt;概要 (helpコマンド)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-2-0&quot;&gt;実際の使用感&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-3-0&quot;&gt;リマインダー&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-3-1&quot;&gt;macos&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-3-2&quot;&gt;slack&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec4-0-0&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec1-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;TODO管理ツールを作りました&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dondakeshimo/todo-cli&quot;&gt;https://github.com/dondakeshimo/todo-cli&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;todo-cliというTODO管理アプリを作りました。
こちら、Go製になります。&lt;/p&gt;
&lt;p&gt;モチベーションは大きく3つあり、以下それぞれについて述べていきます。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-1-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;TODO管理はCLIでやりたい&lt;/h2&gt;
&lt;p&gt;TODOリストにタスクを加える行為は記憶容量を多少減らしてくれたり、作業再開の際にスムーズに導入できるようにといった目的だと思いますが、そのリターンに対して面倒臭さが勝ってしまうことが往々にしてありました。
自分はキーボードで操作可能なものは全てキーボードで操作すべきという強迫観念にも似た信条を持っており、マウスやタッチパッドに手を伸ばすという行為はそれだけで多少の心象的ハードルを乗り越える必要があります。
そのため、タスクの管理におけるコストを極力下げるためにはCLI操作でサッとタスクを残しておき、またその作業に戻った時にスッとタスクを手に取れるようになっていることが理想です。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-2-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;リマインダー機能が欲しい&lt;/h2&gt;
&lt;p&gt;TODO管理をCLIで行うだけなら10は裕に超えるソフトウェアが検索に引っかかります。
特に&lt;a href=&quot;https://github.com/todotxt/todo.txt-cli&quot;&gt;todotxt/todo.txt-cli&lt;/a&gt; はStar数が4.6k (2021/07/23時点) もありしっかりとしたコミュニティと様々な機能が提供されています。
しかし、私が検索した中でリマインダー機能を外部アプリケーションと連携せず、独立で提供しているCLIツールは見つけられませんでした。
(リマインダー機能がついたらそれはタスクリストではなくリマインダーでは？というツッコミを入れられた方は夜道にお気をつけください)。&lt;/p&gt;
&lt;p&gt;TODOリストの本懐はコンテキストスイッチの量とコストを減らすことだと考えています。
タスク管理を行う上で時間を気にしたり、タスクリストを思い出すといった作業は定期的にコンテキストスイッチが発生することに他なりません。
余計なコンテキストスイッチが発生するのを防ぐためにリマンインダーは有効であると考えており、これを手軽に利用できるタスクリストがあると嬉しいと感じていました。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-3-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;必要十分な機能が欲しい&lt;/h2&gt;
&lt;p&gt;その他、自分の欲しかった機能をあげていくと&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;優先度によるソート機能&lt;/li&gt;
&lt;li&gt;グルーピング機能&lt;/li&gt;
&lt;li&gt;タスクのエントリポイント(チケットのURLとか)に直接飛べる機能 &amp;#x3C;- 未実装&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;あたりになります。一番下については自分も本当に欲しいのか半信半疑なのと、良いUXについて迷ったので未実装になっています。&lt;/p&gt;
&lt;p&gt;上の二つの項目においては納得いただける方が多いのではないかと思いますし、リッチなタスクマネージャーを利用すれば大抵の場合該当機能は付属しています。
問題となるのは、リッチなタスクマネージャーを利用した場合コマンドが多くてタスク管理のためのコンテキストスイッチが必要になりそうだった部分です。
コンテキストスイッチを減らすための工夫でコンテキストスイッチが増えたら本末がすっ転んでしまいます。
正直自分が作成した管理アプリがそこまでシンプルかと聞かれるとYESとは言い難い気もしますが、コマンド自体はシンプルなtodo管理アプリを参考に4つ程度に収めたのでわかりやすい方ではないかと思います。(自分で作ったので覚えられているだけかもしれませんが...)&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;インストール方法&lt;/h1&gt;
&lt;p&gt;&lt;a id=&quot;sec2-1-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Go&lt;/h2&gt;
&lt;p&gt;Goをインストールしている方は &lt;code class=&quot;language-text&quot;&gt;go install&lt;/code&gt; するのが管理しやすくて良いと思います。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# Go 1.16+
$ go install github.com/dondakeshimo/todo-cli/cmd/todo@latest

# Go version &amp;lt; 1.16
$ go get -u github.com/dondakeshimo/todo-cli/cmd/todo&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Goのバイナリ置き場に &lt;code class=&quot;language-text&quot;&gt;PATH&lt;/code&gt; を通すことをお忘れなく。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ export PATH=$PATH:$(go env GOPATH)/bin&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a id=&quot;sec2-2-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;バイナリのダウンロード&lt;/h2&gt;
&lt;p&gt;Goがインストールされていない環境をお使いの場合はバイナリの直接ダウンロードもできます。
MacとUbuntuの環境でビルドしたものを用意しています。
それ以外の環境の方はUbuntuのものでお祈りするか、Goをインストールの方お願いいたします。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ TODO_VERSION=1.0.0

$ curl -O https://github.com/dondakeshimo/todo-cli/releases/download/v${TODO_VERSION}/todo-${TODO_VERSION}.macos-10.15.tar.gz

$ tar -xvf todo-${TODO_VERSION}.macos-10.15.tar.gz

$ mv todo path/to/your/$PATH&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a id=&quot;sec3-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;使い方&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dondakeshimo/todo-cli&quot;&gt;https://github.com/dondakeshimo/todo-cli&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;に頑張って書いたので、ほとんどこれの転載になります。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-1-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;概要 (helpコマンド)&lt;/h2&gt;
&lt;p&gt;こちらがtodo-cliのコマンドになります。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ todo --help
Manage Your TODO

Usage:
  todo [command]

Available Commands:
  add         Add a task
  close       Close tasks
  completion  generate the autocompletion script for the specified shell
  configure   Configure your todo-cli
  help        Help about any command
  list        List tasks
  modify      Modify a task
  notify      Notify a task (basicaly be used by system)

Flags:
  -h, --help   help for todo

Use &amp;quot;todo [command] --help&amp;quot; for more information about a command.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;各コマンドのhelpも見られます。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ todo modify -h
Modify a task

Usage:
  todo modify [flags]

Aliases:
  modify, m

Flags:
  -g, --group string         task group. you can get filtered list by group.
  -h, --help                 help for modify
  -i, --id int               task&amp;#39;s ID (default -1)
  -p, --priority int         task&amp;#39;s priority. Lower number means high priority. (default 100)
  -d, --remind_time string   remind_time (2021/3/3 03:03, 2021/3/3, +2h3m, task-4h15m)
  -r, --reminder string      choose reminder from [macos, slack]
      --remove_reminder      remove reminder. this option overrides reminder option
  -t, --task string          task contents&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a id=&quot;sec3-2-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;実際の使用感&lt;/h2&gt;
&lt;p&gt;次に実際にどのように使用するかを見ていきます。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ todo list
+----+--------------------------------+----------------+-------+----------+----------+
| ID |              Task              |   RemindTime   | Group | Reminder | Priority |
+----+--------------------------------+----------------+-------+----------+----------+
|  1 | deleting or modifying this     | 2099/1/1 00:00 |       |          |        0 |
|    | task is your first TODO        |                |       |          |          |
+----+--------------------------------+----------------+-------+----------+----------+

$ todo close -i=1

$ todo l
+----+------+------------+-------+----------+----------+
| ID | Task | RemindTime | Group | Reminder | Priority |
+----+------+------------+-------+----------+----------+
+----+------+------------+-------+----------+----------+

$ todo add &amp;quot;must task&amp;quot; -d=&amp;quot;2021/03/03 12:00&amp;quot; -g=&amp;quot;project x&amp;quot; -r=slack -p=0

$ todo l
+----+-----------+----------------+-----------+----------+----------+
| ID |   Task    |   RemindTime   |   Group   | Reminder | Priority |
+----+-----------+----------------+-----------+----------+----------+
|  1 | must task | 2021/3/3 12:00 | project x | slack    |        0 |
+----+-----------+----------------+-----------+----------+----------+

$ todo a &amp;quot;boring task&amp;quot; -g=&amp;quot;project x&amp;quot;

$ todo a &amp;quot;important task&amp;quot; -d=&amp;quot;2022/01/01&amp;quot; -p=50

$ todo l
+----+----------------+----------------+-----------+----------+----------+
| ID |      Task      |   RemindTime   |   Group   | Reminder | Priority |
+----+----------------+----------------+-----------+----------+----------+
|  1 | must task      | 2021/3/3 12:00 | project x | slack    |        0 |
|  2 | important task | 2022/1/1 00:00 |           |          |       50 |
|  3 | boaring task   |                | project x |          |      100 |
+----+----------------+----------------+-----------+----------+----------+

$ todo m -i=1 -t=&amp;quot;should task&amp;quot; -p=10

$ todo l -g=&amp;quot;project x&amp;quot;
+----+--------------+----------------+-----------+----------+----------+
| ID |     Task     |   RemindTime   |   Group   | Reminder | Priority |
+----+--------------+----------------+-----------+----------+----------+
|  1 | should task  | 2021/3/3 12:00 | project x | slack    |       10 |
|  3 | boaring task |                | project x |          |      100 |
+----+--------------+----------------+-----------+----------+----------+

$ todo conf --hide_reminder=true --show_config
columnwidth: 30
hidegroup: false
hidepriority: false
hidereminder: true
slackmentionto: XXXXXXXXXX
slackwebhookurl: https://hooks.slack.com/services/XXXXXXXXXX/XXXXXXXXXX/XXXXXXXXXX
taskfilepath: /home/dondakeshimo/.local/share/todo/todo.json

$ todo l
+----+----------------+----------------+-----------+----------+
| ID |      Task      |   RemindTime   |   Group   | Priority |
+----+----------------+----------------+-----------+----------+
|  1 | should task    | 2021/3/3 12:00 | project x |       10 |
|  2 | important task | 2022/1/1 00:00 |           |       50 |
|  3 | boaring task   |                | project x |      100 |
+----+----------------+----------------+-----------+----------+&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用感はこんな感じになります。&lt;/p&gt;
&lt;p&gt;configのところで察された方もいるかもしれませんが、全ての情報をファイルで持っています。
短期間のTODO管理に堅牢な永続化は不要ですし、トランザクションや競合もユーザが一人想定なので不要です。
ファイルで十分だったのでそのように実装したのですが、副次的にファイルを管理することで複数のTODO管理を切り替えたり、新しい環境にTODOリストを引き継ぐことが可能になりました。(私はそのようなことはしないと思いますが)&lt;/p&gt;
&lt;p&gt;後はそうですね、上記の例で見せられていない部分としてcloseする際のidは複数選択可能です。 &lt;code class=&quot;language-text&quot;&gt;-id 1,2,3,4&lt;/code&gt; のように指定できます。
また、 &lt;code class=&quot;language-text&quot;&gt;-d&lt;/code&gt; オプションは相対時間で指定することが可能になっています。これは後述するリマインダーの使用方法で使っています。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-3-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;リマインダー&lt;/h2&gt;
&lt;p&gt;実装に大いに苦しめられましたが、使用者からしたら開発者の苦労話など基本的にどうでも良いと思うので別記事にまとめます。&lt;/p&gt;
&lt;p&gt;リマインダーは2種類用意しています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macos&lt;/li&gt;
&lt;li&gt;slack&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;名前の通りmacosはMacでのみ利用可能です。Slackは事前に設定が必要になりますが、linux環境できます。
Windows環境については未対応になります(私がWindowsで開発を行わないため、しばらく対応されないと思います)。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-3-1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;macos&lt;/h3&gt;
&lt;p&gt;macosはシステムのポップアップを用いたリマインダー機能になります。
リマインダーの名前は &lt;code class=&quot;language-text&quot;&gt;macos&lt;/code&gt; となっています。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ todo a &amp;quot;remind me this task&amp;quot; -r=macos -d=+1m

$ todo l
+----+---------------------+-----------------+-------+----------+----------+
| ID |        Task         |   RemindTime    | Group | Reminder | Priority |
+----+---------------------+-----------------+-------+----------+----------+
|  1 | remind me this task | 2021/3/3 01:01  |       | macos    |      100 |
+----+---------------------+-----------------+-------+----------+----------+&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上記のようにタスクを登録すれば、1分後に下記のような通知を受け取れます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/23194960/126190791-be2dae4a-5e56-4e59-8151-a6d88e48f0e9.png&quot; alt=&quot;notification&quot;&gt;&lt;/p&gt;
&lt;p&gt;doneボタンを押すとタスクは自動的にクローズされて、skipを押すと特に何もしません。
当初は何分後に再通知するみたいなボタンを足そうかと考えていた気がするのですが、疲れた時期に実装していた箇所であることと、結局あったところで自分は使わないなと思い未実装です。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-3-2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;slack&lt;/h3&gt;
&lt;p&gt;Slackを用いたリマインダーを利用するためには事前に設定が必要になります。
&lt;a href=&quot;https://slack.com/intl/ja-jp/help/articles/115005265063-Slack-%E3%81%A7%E3%81%AE-Incoming-Webhook-%E3%81%AE%E5%88%A9%E7%94%A8&quot;&gt;Slack での Incoming Webhook の利用&lt;/a&gt; を参考にIncoming Webhookを通知させたいSlackのworkspaceに導入したいただく必要があります。
こちらで設定した際に得られるWebhook URLと、workspaceにおける自分のmember IDをtodo-cliに設定します。
設定コマンドは下記の通りになります。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ todo conf --slack_webhook_url=&amp;quot;https://hooks.slack.com/services/XXXXXXXX/XXXXXXXX&amp;quot; --slack_mention_to=XXXXXXXXXX&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;それでは &lt;code class=&quot;language-text&quot;&gt;-r slack&lt;/code&gt; オプションを使ってタスクを追加します。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ todo a &amp;quot;remind me this task in slack\!&amp;quot; -r=slack -d=+1m

$ todo l
+----+-------------------------------+-----------------+-------+----------+----------+
| ID |             Task              |   RemindTime    | Group | Reminder | Priority |
+----+-------------------------------+-----------------+-------+----------+----------+
|  1 | remind me this task in slack! | 2021/7/20 01:11 |       | slack    |      100 |
+----+-------------------------------+-----------------+-------+----------+----------+&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1分後に下図のような通知がslackに届いていると思います。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/23194960/126192217-cee8469b-b917-4770-ab76-f604556bd3e2.png&quot; alt=&quot;notification in slack&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec4-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;まとめ&lt;/h1&gt;
&lt;p&gt;本記事ではtodo-cliを作成した理由と使用方法の紹介を行いました。
是非使用の検討をしていただければと思います。&lt;/p&gt;
&lt;p&gt;開発における工夫した点や学び気づきなどは別記事を書こうと思うのでそちらも見ていただければ幸いです。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[クリーンアーキテクチャをまとめる]]></title><description><![CDATA[クリーンアーキテクチャを読んだので頭の整理がしたい]]></description><link>https://dondakeshimo.github.io/tech-blog/blog/clean-architecture-uncle-bob</link><guid isPermaLink="false">https://dondakeshimo.github.ioblog/clean-architecture-uncle-bobクリーンアーキテクチャをまとめる</guid><dc:creator><![CDATA[dondakeshimo]]></dc:creator><pubDate>Mon, 31 May 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;目次 &lt;!-- exclude-toc --&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-0-0&quot;&gt;動機&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec2-0-0&quot;&gt;設計の原則&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-1-0&quot;&gt;プログラミングパラダイム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-1-1&quot;&gt;構造化プログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-1-2&quot;&gt;オブジェクト指向プログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-1-3&quot;&gt;関数型プログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-1-4&quot;&gt;パラダイムのまとめ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-2-0&quot;&gt;SOLID原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-2-1&quot;&gt;単一責任の原則 (SRP: Single Responsibility Principle)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-2-2&quot;&gt;オープン・クローズドの原則 (OCP: Open-Closed Principle)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-2-3&quot;&gt;リスコフの置換原則 (LSP: Liskov Substitution Principle)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-2-4&quot;&gt;インターフェイス分離の原則 (ISP Interface Segregation Principle)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-2-5&quot;&gt;依存関係逆転の原則 (DIP: Dependency Inversion Principle)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-3-0&quot;&gt;コンポーネントの原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-3-1&quot;&gt;再利用・リリース等価の原則 (REP)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-3-2&quot;&gt;閉鎖性共通の原則 (CCP)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-3-3&quot;&gt;全再利用の原則 (CRP)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-3-4&quot;&gt;REP, CCP, CRPの関係&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-3-5&quot;&gt;非循環依存関係の原則 (ADP)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-3-6&quot;&gt;安定依存の原則 (SDP)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-3-7&quot;&gt;安定度・抽象度等価の原則 (SAP)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec3-0-0&quot;&gt;アーキテクチャ&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-1-0&quot;&gt;システム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-1-1&quot;&gt;開発&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-1-2&quot;&gt;デプロイ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-1-3&quot;&gt;運用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-1-4&quot;&gt;保守&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-2-0&quot;&gt;アーキテクトの思考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-2-1&quot;&gt;選択肢&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-2-2&quot;&gt;切り離し&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-2-3&quot;&gt;境界線&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-3-0&quot;&gt;アーキテクチャ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-3-1&quot;&gt;方針とレベル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-3-2&quot;&gt;ビジネスルール&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-3-3&quot;&gt;クリーンアーキテクチャ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-3-4&quot;&gt;インターフェイスアダプター&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-3-5&quot;&gt;境界&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-3-6&quot;&gt;メインコンポーネント&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-3-7&quot;&gt;詳細&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-3-8&quot;&gt;設計手順&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-3-9&quot;&gt;パッケージング&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec4-0-0&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec1-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;動機&lt;/h1&gt;
&lt;p&gt;業務にて設計に携わることがあり、何度か聞いていたクリーンアーキテクチャというものを調べてみた。
ブログ記事や解説記事を漁っているうちに、これは原本を呼んだ方が早そうだと思い書籍を購入した。
(後から気づいたが、本人のブログ記事が原点だったが説明が最小限なので流石にあれだけでは理解が難しい。)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.amazon.co.jp/dp/B07FSBHS2V/ref=dp-kindle-redirect?_encoding=UTF8&amp;#x26;btkr=1&quot;&gt;Clean Architecture 達人に学ぶソフトウェアの構造と設計&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;崩壊したコードを書くほうがクリーンなコードを書くよりも常に遅い&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;素晴らしい本だったのだが、幾分情報量が多いのでここにまとめることで頭を整理しようと思う。
崩壊した脳内で設計を行うよりもクリーンにした頭で設計をする方が常に早いのだ。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;設計の原則&lt;/h1&gt;
&lt;p&gt;&lt;a id=&quot;sec2-1-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;プログラミングパラダイム&lt;/h2&gt;
&lt;p&gt;&lt;a id=&quot;sec2-1-1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;構造化プログラミング&lt;/h3&gt;
&lt;p&gt;goto文の使用がプログラミングにおいて有害であることが示された。
あらゆるプログラムは「順次」「選択」「反復」の3つの構造で構築できることが特定され、それぞれが数学的に証明された。
全てのモジュールは証明可能な単位に再帰的に分割することが可能であるとしたのが構造化プログラミングであり、
機能によりモジュールは分割できる。
全てのモジュールに対して数学的に正しいことを証明することはできないが、科学的にそれをテストで補うことが可能である。
言い換えればテスト可能な単位までモジュールを分割することが構造化プログラミングのパラダイムにおいてのベストプラクティスである。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-1-2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;オブジェクト指向プログラミング&lt;/h3&gt;
&lt;p&gt;「カプセル化」「継承」「ポリモーフィズム」に代表されるパラダイムである。
ただし、カプセル化と継承についてはパラダイムシフトが行われる前のC言語から普通に使用されていた概念である。
ここで重要になるのがポリモーフィズムとなる。
ポリモーフィズムの概念がC言語時代になかったわけではないが、安全に使用することはできなかった。
ポリモーフィズムを使用することで依存性を逆転させることが可能になり、ソースコードの依存関係を制御の流れから逆転させることができる。
依存関係逆転を用いることで処理の中核にある重要なビジネスルールをその他の依存関係から独立させることが可能になる。
まとめると、オブジェクト指向プログラミングの登場によって、ポリモーフィズムを用いることで、
システムにある全てのソースコードの依存関係を絶対的に制御する能力を人類は手に入れた。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-1-3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;関数型プログラミング&lt;/h3&gt;
&lt;p&gt;関数型プログラミングでは再代入をすることができない。
全ての変数は不変であることで、競合状態、デッドロック状態、並行更新の問題が発生しなくなる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-1-4&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;パラダイムのまとめ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;構造化プログラミングは、直接的な制御の移行に規律を課すものである。&lt;/li&gt;
&lt;li&gt;オブジェクト指向プログラミングは、間接的な制御の移行に規律を課すものである。&lt;/li&gt;
&lt;li&gt;関数型プログラミングは、代入に規律を課すものである。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec2-2-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;SOLID原則&lt;/h2&gt;
&lt;p&gt;関数やクラスの設計原則をまとめたSOLID原則を紹介する。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-2-1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;単一責任の原則 (SRP: Single Responsibility Principle)&lt;/h3&gt;
&lt;p&gt;システムに対しある変更を望むグループのことを &lt;strong&gt;アクター&lt;/strong&gt; と呼ぶこととする。
単一責任の原則とは対象のアクターが複数あるコードは分割するべきであるという原則である。
分割することで増えてしまう関数やクラスはFacadeパターンを使用することでインターフェイスを統一することができる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-2-2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;オープン・クローズドの原則 (OCP: Open-Closed Principle)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;ソフトウェアの構成要素は拡張に対しては開いていて、修正に対して閉じていなければならない
『アジャイルソフトウェア開発の奥義 第2版』 (SBクリエイティブ) より引用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;依存性をコントロールし情報を隠蔽することで、各々の変更の影響を最小限に機能追加については容易にするという原則である。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-2-3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;リスコフの置換原則 (LSP: Liskov Substitution Principle)&lt;/h3&gt;
&lt;p&gt;リスコフの置換原則とは派生型に対する定義である。
T型がS型の派生型となるにはS型で定義されたプログラムPで、
S型のオブジェクトの代わりにT型のオブジェクトを使用してもPの振る舞いが変わらない必要がある。
これはアーキテクチャのレベルでも適用され、派生型と捉えられるあらゆる設計は厳密に置き換え可能でなければならない。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-2-4&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;インターフェイス分離の原則 (ISP Interface Segregation Principle)&lt;/h3&gt;
&lt;p&gt;別のモジュール、コンテキスト、技術を使用する際は分離されたインターフェイスを使用すること。
直接依存してしまうと、密結合が生まれてしまいコンパイルの時間が伸び、障害に対してロバストでなくなる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-2-5&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;依存関係逆転の原則 (DIP: Dependency Inversion Principle)&lt;/h3&gt;
&lt;p&gt;コードの変化のしやすさを考えると、 &lt;code class=&quot;language-text&quot;&gt;具象クラス &amp;gt; 抽象クラス &amp;gt; インタフェース&lt;/code&gt; となる、なるべきである。
そのため、具象クラスへの依存は可能な限り減らす、参照、継承、オーバーライドどれも御法度である。
具象インスタンスの作成をする際は &lt;strong&gt;Abstract Factoryパターン&lt;/strong&gt; を利用することで、直接具象を参照しなくてもよくなる。
このように具象への参照を忌避していくと、最終的には全ての具象を扱う関数が唯一存在することとなり、
これはmainコンポーネントと呼ばれることが多い。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-3-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;コンポーネントの原則&lt;/h2&gt;
&lt;p&gt;&lt;a id=&quot;sec2-3-1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;再利用・リリース等価の原則 (REP)&lt;/h3&gt;
&lt;p&gt;再利用のためのグループ化を行う。
ひとつのコンポーネントを形成するクラスやモジュールは、まとめてリリース可能でなければならない。
同じバージョン番号を共有し、同じリリースプロセスを経て、同じリリースドキュメントを持っている状態は合理的であり、あるべき姿である。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-3-2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;閉鎖性共通の原則 (CCP)&lt;/h3&gt;
&lt;p&gt;保守性のためのグループ化を行う。
単一責任の原則をコンポーネントのために言い換えたもの。
コンポーネントを変更する理由が複数あるべきではない。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-3-3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;全再利用の原則 (CRP)&lt;/h3&gt;
&lt;p&gt;不要なリリース作業を減らすための分割を行う。
一緒に用いられることが多いクラスやモジュールはひとまとめにすること。
密結合なクラスやモジュールも同様である。
逆に、同時に使用されることがほとんどないクラスは分離されるべきである。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-3-4&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;REP, CCP, CRPの関係&lt;/h3&gt;
&lt;p&gt;REPとCCPは包含関係にあり、どちらもコンポーネントを大きくする方向に働くものである。
一方、CRPはコンポーネントを小さくする方向に働く原則であり、これら3つの原則のバランスをうまくとる必要がある。
REPとCCPのみを守るとリリース頻度が増加する。
CCPとCRPのみを守ると再利用性が低下する。
CPRとREPのみを守ると変更すべきコンポーネントが増大する。
プロジェクト初期はREPを軽視する傾向にあり、プロジェクトの成熟に連れて、徐々にREPへ重心を寄せていくことが多い。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-3-5&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;非循環依存関係の原則 (ADP)&lt;/h3&gt;
&lt;p&gt;コンポーネント間の依存は循環してはならないという名前通りの原則。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-3-6&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;安定依存の原則 (SDP)&lt;/h3&gt;
&lt;p&gt;変更しやすいコンポーネントは変更しにくいコンポーネントから依存されてはならない。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-3-7&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;安定度・抽象度等価の原則 (SAP)&lt;/h3&gt;
&lt;p&gt;コンポーネントの抽象度はその安定度と同程度んでなければならない。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;アーキテクチャ&lt;/h1&gt;
&lt;p&gt;アーキテクチャとはシステムに与えられた形状である。
アーキテクチャの目的はシステムの開発、デプロイ、運用、保守を容易にすることである。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;それらを容易にするための戦略は、できるだけ長い期間、できるだけ多く選択肢を残すことである。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a id=&quot;sec3-1-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;システム&lt;/h2&gt;
&lt;p&gt;&lt;a id=&quot;sec3-1-1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;開発&lt;/h3&gt;
&lt;p&gt;マイクロサービスアーキテクチャでも読んだ通り、1チームが1コンポーネントを担当するべきであるため、
形状は自ずとチームに寄り添う形で決まっていくはずである。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-1-2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;デプロイ&lt;/h3&gt;
&lt;p&gt;デプロイの文脈でアーキテクチャが目指すべきことは単一のアクションでデプロイが行えることである。
単に自動デプロイ環境が整っていることを指すのではなく、対象のコンポーネントが独立してデプロイできることを指す。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-1-3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;運用&lt;/h3&gt;
&lt;p&gt;アーキテクチャの運用における仕事はシステムへの理解の手助けとなることだ。
形状がシステムを端的に表せているならば、システムへの理解は容易となる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-1-4&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;保守&lt;/h3&gt;
&lt;p&gt;保守のコストとは既存のコードを掘り起こし、新しい機能の追加や欠陥の修正に最適な場所や戦略を見つけるコストである。
正しいアーキテクチャは上記コストを大幅に削減でき、人的リソースの増大を防ぐ。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-2-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;　アーキテクトの思考&lt;/h2&gt;
&lt;p&gt;&lt;a id=&quot;sec3-2-1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;選択肢&lt;/h3&gt;
&lt;p&gt;システムは大きく「方針」と「詳細」の二つに分割できる。
この時、アーキテクトは方針とは無関係に詳細を決めながら重要でない詳細については選択肢を残してアーキテクチャを構築していく。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-2-2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;切り離し&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;水平方向の分割としてレイヤー分割&lt;/li&gt;
&lt;li&gt;垂直方向の分割としてユースケース分割&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上記の分割を行う規模として&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ソースレベル&lt;/li&gt;
&lt;li&gt;デプロイ(バイナリ)レベル&lt;/li&gt;
&lt;li&gt;サービス(実行単位)レベル&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;などが考えられる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-2-3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;境界線&lt;/h3&gt;
&lt;p&gt;1つのクラス、モジュール、コンポーネントにとって重要なものと重要でないものの間には境界線を引く。&lt;/p&gt;
&lt;h4&gt;インターフェイスと継承&lt;/h4&gt;
&lt;p&gt;インターフェイスとその継承の間には境界線が発生する。
対象の単位内でインターフェイスが定義さえされていれば、インターフェイスの実装部分については無関心でいられるためである。&lt;/p&gt;
&lt;h4&gt;デプロイコンポーネント&lt;/h4&gt;
&lt;p&gt;動的リンクライブラリはデプロイレベルの切り離しとして理解でき、それぞれの動的リンクライブラリには境界がある。&lt;/p&gt;
&lt;h4&gt;スレッド&lt;/h4&gt;
&lt;p&gt;モノリスでも動的リンクライブラリでもスレッドでの分割も行うことができる。&lt;/p&gt;
&lt;h4&gt;ローカルプロセス&lt;/h4&gt;
&lt;p&gt;スレッドよりも明確な境界線としてローカルプロセスもある。&lt;/p&gt;
&lt;h4&gt;サービス&lt;/h4&gt;
&lt;p&gt;現状最も強い境界線はサービスである。
同じプロセッサやマルチコアの環境で同時に動作させることも可能だが、そのような物理的な制約は特に問題にならない。
あらゆる通信はネットワークを経由して行われることが前提となる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-3-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;アーキテクチャ&lt;/h2&gt;
&lt;p&gt;&lt;a id=&quot;sec3-3-1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;方針とレベル&lt;/h3&gt;
&lt;p&gt;プログラムは入力を出力に変換する &lt;strong&gt;方針&lt;/strong&gt; を詳細に記述したものである。
この方針は細分化され、入力の検証や、出力のフォーマット設定の記述をしている方針がある。
これらの方針には &lt;strong&gt;レベル&lt;/strong&gt; が存在する。&lt;/p&gt;
&lt;p&gt;「レベル」の定義は「入力と出力からの距離」である。
上述の入力の検証や、出力のフォーマット設定などは入出力に限りなく近いため下位のレベルに位置する。
逆に上位のレベルとしては受け取った入力に対して行う変換作業などが挙げられる。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ソースコードの依存性はデータフローから切り離し、レベルと結びつけるべきである。&lt;/em&gt;
どのような場合も、下位レベルのコンポーネントが上位レベルのコンポーネントに依存するように設計する。&lt;/p&gt;
&lt;p&gt;方針のグルーピングについてはSRPやCCPに基づいて行うが、
その際に重要なのは上位レベルの方針は下位レベルの方針よりも変更の頻度が低く、変更の理由が重要である。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-3-2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;ビジネスルール&lt;/h3&gt;
&lt;h4&gt;エンティティ&lt;/h4&gt;
&lt;p&gt;最重要ビジネスルールのことをエンティティと呼ぶ。
エンティティは最上位のレベルに位置することとなる。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;/tech-blog/tech-blog/blog/evans-eric-ddd&quot;&gt;エリック・エヴァンスのドメイン駆動設計をまとめる&lt;/a&gt;
にて扱ったエンティティとは別の概念であり、ドメイン駆動設計でいうところのコアドメインにあたる。&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;ユースケース&lt;/h4&gt;
&lt;p&gt;ユースケースはアプリケーション固有のビジネスルールを記述する。
アプリケーション固有のビジネスルールとはエンティティをいつ・どこで呼び出すかを規定することである。&lt;/p&gt;
&lt;p&gt;ユースケースでは実際の入出力の詳細を知ることはなく、エンティティはユースケースを知ることがない。
ここからユースケースがエンティティと入出力の詳細の中間のレベルに位置していることがわかる。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;/tech-blog/tech-blog/blog/evans-eric-ddd&quot;&gt;エリック・エヴァンスのドメイン駆動設計をまとめる&lt;/a&gt;
でいうところのドメイン層のサービス、特に粒度を大きくとるために使用するサービスに近いものであると考えている。&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;リクエストとレスポンスのモデル&lt;/h4&gt;
&lt;p&gt;ユースケースは入力データを期待し、出力データを生成するが具体的な入出力の詳細に触れてはいけない。
そのため、入力データ、出力データは双方入出力の詳細に依存していないデータである必要がある。
ここで、SRPから、これらのデータ構造にエンティティへの参照を含めてはならない。&lt;/p&gt;
&lt;h4&gt;フレームワークとアーキテクチャ&lt;/h4&gt;
&lt;p&gt;はっきりさせておく必要があるのは、フレームワークはアーキテクトによって選択肢が残されるべき詳細であるということである。
フレームワークによってアーキテクチャが規定されることはなく、あくまでツールに過ぎないことを認識する必要がある。
また、テストについてもフレームワークに依存することなくユニットテストが実行できることが望ましい。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-3-3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;クリーンアーキテクチャ&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&quot;gatsby-resp-image-figure&quot; style=&quot;&quot;&gt;
    &lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 772px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 73.6%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDAQX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAAB6eycmog1/8QAGBAAAwEBAAAAAAAAAAAAAAAAAAECIRH/2gAIAQEAAQUCdMVHSsJwl5//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAVEAEBAAAAAAAAAAAAAAAAAAAgIf/aAAgBAQAGPwKL/8QAGhAAAgMBAQAAAAAAAAAAAAAAAAERIUExgf/aAAgBAQABPyEhW2W4mWym/DRtklnp/9oADAMBAAIAAwAAABBsz//EABgRAAIDAAAAAAAAAAAAAAAAAAABIaGx/9oACAEDAQE/ENocH//EABcRAAMBAAAAAAAAAAAAAAAAABARIWH/2gAIAQIBAT8Qrwf/xAAbEAEAAwEBAQEAAAAAAAAAAAABABEhMUFRYf/aAAgBAQABPxBSgvaA6/WMGtgsT0jggIV2C2sCX02EJs4A+fsRFFt2f//Z&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Clean Architecture&quot;
        title=&quot;Clean Architecture&quot;
        src=&quot;/tech-blog/static/07b2e4403c83a8b377ad14ab3589044c/37601/CleanArchitecture.jpg&quot;
        srcset=&quot;/tech-blog/static/07b2e4403c83a8b377ad14ab3589044c/9a1e7/CleanArchitecture.jpg 250w,
/tech-blog/static/07b2e4403c83a8b377ad14ab3589044c/10bbb/CleanArchitecture.jpg 500w,
/tech-blog/static/07b2e4403c83a8b377ad14ab3589044c/37601/CleanArchitecture.jpg 772w&quot;
        sizes=&quot;(max-width: 772px) 100vw, 772px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;
    &lt;figcaption class=&quot;gatsby-resp-image-figcaption&quot;&gt;Clean Architecture&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html&quot;&gt;https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html&lt;/a&gt; より引用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;優れたアーキテクチャの特性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;フレームワーク非依存: フレームワークをツールとして扱える&lt;/li&gt;
&lt;li&gt;テスト可能: ビジネスルールはUI、データベース、ウェブサーバー、その他の外部要素がなくてもテストできる&lt;/li&gt;
&lt;li&gt;UI非依存: UIはシステムの他の部分の変更と独立して変更できる&lt;/li&gt;
&lt;li&gt;データベース非依存: ビジネスルールの変更なしにデータベースを自由に変更できる&lt;/li&gt;
&lt;li&gt;外部エージェント非依存: ビジネスルールは外部のインターフェイスについて何も知らない&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;依存性のルール&lt;/h4&gt;
&lt;p&gt;円の中心に近づくほどレベルが上がっていることを表している。
つまり、 &lt;strong&gt;ソースコードの依存性は、内側岳に向かっていなければならない。&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;境界線の越え方&lt;/h4&gt;
&lt;p&gt;ユースケースからプレゼンターを呼び出したい時など、上記のルールからユースケースがプレゼンターを直接呼び出し、
プレゼンターに依存することは許されていない。
内側から外側の層を使用する必要がある場合はDIPを利用する。&lt;/p&gt;
&lt;h4&gt;境界線を越えるデータ&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;構造体&lt;/li&gt;
&lt;li&gt;データ転送オブジェクト&lt;/li&gt;
&lt;li&gt;関数呼び出しの引数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;など選択肢はいくつもあるが、独立した単純なデータ構造であることが重要である。
エンティティオブジェクトやデータベースの行をそのまま渡すようなことをしてはいけない。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-3-4&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;インターフェイスアダプター&lt;/h3&gt;
&lt;h4&gt;Humble Object&lt;/h4&gt;
&lt;p&gt;Humble Objectパターンは振る舞いをユニットテストがしやすいように二つに分割するパターンである。
一つのモジュールは控えめ(Humble)で、ここにはテストが難しい振る舞いのみが記述される。
例としてはGUIが挙げられる。GUIにおいて画面に表示されているものの確認の自動化は極めて難しいが、
その他の振る舞いの大部分は簡単にテストできる。&lt;/p&gt;
&lt;h4&gt;PresenterとView&lt;/h4&gt;
&lt;p&gt;上述のHubmle Objectパターンで登場したGUIにおける表示とその他の部分を指す。
表示の部分をView, その他の部分をPresenterと言う。
Viewはテストが難しいため、表示だけに専念して、データの移動や取得などのロジックは含まないようにする。
代わりにテスト可能な部分の全てはPresenterに含まれる。
Presenterで全てのデータを取得、処理した後にViewが解釈でき、
&lt;strong&gt;そのまま表示できる&lt;/strong&gt; ViewModelと呼ばれるようなデータ構造体として受け渡す。
ViewがやるべきことはViewModelからデータを読み込み画面に表示する以外なく、Humbleに保たれる。&lt;/p&gt;
&lt;h4&gt;データベースとゲートウェイ&lt;/h4&gt;
&lt;p&gt;ユースケースインタラクターとデータベースの間にあるのがゲートウェイである。
ゲートウェイはアプリケーションのビジネスルールとは格別され、データのCRUDの実際の操作にのみ焦点を当てる。
ゲートウェイはデータベースと指定されたやりとりをしているだけなのでHumble Objectと言える。
また、データベースとのやりとりの部分、例えばSQL文の記述になると思われるが、ゲートウェイに隔離しておくことで、
ユースケースインタラクターが独立してテスト可能になる。&lt;/p&gt;
&lt;p&gt;さて、ここでデータマッパーに代表されるマッピング処理はどこに含まれるかだが、
当然ユースケースインタラクターではなく、ゲートウェイに含まれる。
ゲートウェイの中でもデータベースとゲートウェイの境界に位置する技術がデータマッパーである。&lt;/p&gt;
&lt;h4&gt;サービスリスナー&lt;/h4&gt;
&lt;p&gt;アプリケーションが他のサービスと通信する必要がある場合も、Hubmle Objectパターンを意識する。
境界を越える際はシンプルなデータ構造を持ってアプリケーションに渡すことや、詳細の情報をアプリケーション層が扱わないことを意識する。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-3-5&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;境界&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;You Aren&apos;t Going to Need It. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通称YAGNIから必要に迫られる前の抽象化は悪だとされてきた。
しかし、アーキテクトは時に変化を予測してYAGNIを違反する必要がある。&lt;/p&gt;
&lt;p&gt;部分的な境界を利用することで、完全な境界は形成せずに境界を作成する準備だけすることもできるが、
そのような境界は不完全なため、境界の維持は実装者のモラルに頼らざるを得ない。&lt;/p&gt;
&lt;p&gt;アーキテクトは実装する境界と無視する境界を決定する必要があり、
それはプロジェクトの初期から運用に至るまでで何度も考察されるべきである。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-3-6&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;メインコンポーネント&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Mainコンポーネントは、究極的な詳細（最下位レベルの方針）である。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;全てのシステムでは少なくとも一つ、その他のコンポーネントを作成・調整・監督するコンポーネントが必要になる。
そのようなコンポーネントをメインコンポーネントと呼ぶ。
依存関係の注入や、設定ファイルのパス指定などコードの本体で把握したくない文字列を読み込む。&lt;/p&gt;
&lt;p&gt;Mainは、初期状態や構成を設定して、外部リソースを集め、アプリケーションの上位レベルの方針に制御を渡すプラグインである。
例えば、開発用、テスト用、本番用のMainを用意することもできる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-3-7&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;詳細&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;データベース&lt;/li&gt;
&lt;li&gt;ウェブ&lt;/li&gt;
&lt;li&gt;フレームワーク&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらは全て決定を最後まで遅らせるべき詳細にあたる。
どれもビジネスルールと密結合させるべきではない。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-3-8&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;設計手順&lt;/h3&gt;
&lt;h4&gt;アクターとユースケースの洗い出し&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;システムの最初のアーキテクチャを決めるための第一歩は、アクターとユースケースを見つけることだ。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;システムに変更を要求する可能性のあるアクターを探しだす。
単一責任の原則からあるアクターへの変更が他のアクターに影響を与えないようにしたい。&lt;/p&gt;
&lt;p&gt;次に、アクターごとに考えられるユースケースを洗い出す。
ユースケースにもレベルが存在し、上位の概念ほど抽象化が高い。
例えば、家具のカタログを閲覧すると言うユースケースはアクターが複数いる場合には抽象ユースケースとなる。
管理者としてカタログを閲覧するのか、購入者としてカタログを購入するのかは本質的に異なるが、上位のレベルでは同じものであるため、
カタログを閲覧すると言う抽象ユースケースを継承したユースケースと考えることができる。&lt;/p&gt;
&lt;h4&gt;コンポーネントアーキテクチャ&lt;/h4&gt;
&lt;p&gt;コンポーネントアーキテクチャについてはここまでで議論されてきたように、詳細になるに従って具象化させていくように切り分けていく。
切り分け方としては伝統的なビュー、プレゼンター、インタラクター、コントローラー、ユーティリティーなどが考えられるが、
こここそがアーキテクトの腕の見せ所であると考えられるので、それぞれのプロジェクトごとに考えていくしかない。&lt;/p&gt;
&lt;h4&gt;依存性管理&lt;/h4&gt;
&lt;p&gt;依存性についても先述の通り、制御の流れと逆向きに、抽象化の向きに沿って、管理していく。
ここで一つ重要なのが、アクターごとに独立に変更や機能追加ができるようにしておくことである。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-3-9&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;パッケージング&lt;/h3&gt;
&lt;h4&gt;レイヤーによるパッケージング&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;web&lt;/li&gt;
&lt;li&gt;service&lt;/li&gt;
&lt;li&gt;data&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;などのレイヤーの名称によってパッケージを分割する方法。
特に考えることなくパッケージングができるため簡単ではあるが、
プロジェクトが大きくなるとこれらの分割だけでは可読性が大きく損なわれる。
また、アーキテクチャがドメイン知識について何か提示してくれることがない。&lt;/p&gt;
&lt;h4&gt;機能によるパッケージング&lt;/h4&gt;
&lt;p&gt;レイヤーによるパッケージングを水平方向での分割とすると、機能による分割は垂直方向の分割である。
ドメイン駆動設計の用語で言うところの集約ルートに基づいて分割する。
こちらの方がアーキテクチャがドメイン知識についてのヒントとなるだろう。&lt;/p&gt;
&lt;h4&gt;ポートとアダプターによるパッケージング&lt;/h4&gt;
&lt;p&gt;クリーンアーキテクチャのレイヤー図のうちビジネスルールを表す、「Entities」「Use Cases」はドメイン層にあたる。
その外側はインフラストラクチャ層であり、この二つは確実に分割されている必要がある。
基本的には上記のことを踏まえたレイヤーによるパッケージングになる。&lt;/p&gt;
&lt;h4&gt;コンポーネントによるパッケージング&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;関連する機能をよくできたクリーンなインターフェイスの向こう側に閉じ込めて、アプリケーションなどの実行環境の内側に置いたもの&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;とコンポーネントを定義する。
コンポーネントに従ってパッケージを分割していくことになるが、
上記の考え方と違うのは永続化のコードがドメインのコードと同様のパッケージに属することだ。
当然、パッケージ内で依存性のコントロールは行われるため、分割の箇所が変わるだけで原則に違反するわけではない。
こうすることで、コントローラ層から直接インフラストラクチャ層を呼び出すようなヤンチャができなくなる。
また、コンポーネントと言う単位で分割することによってパッケージの責務がわかりやすくなるので、
コード利用者も管理者もコードの把握が楽になると言う利点もある。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec4-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;まとめ&lt;/h1&gt;
&lt;p&gt;自分の解釈では下記を満たしていればクリーンアーキテクチャである。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安定度が大きくなるほど抽象度を上げる&lt;/li&gt;
&lt;li&gt;依存性逆転の法則を利用して下位のコンポーネントを上位のコンポーネントに依存させない&lt;/li&gt;
&lt;li&gt;コアドメインのビジネスルールは独立させる&lt;/li&gt;
&lt;li&gt;アプリケーション固有のビジネスルールはコアドメインのビジネスルールにのみ依存する&lt;/li&gt;
&lt;li&gt;変更の多い箇所はHumble Objectパターンで分離する&lt;/li&gt;
&lt;li&gt;テストが難しい箇所もHumble Objectパターンで分離する &lt;/li&gt;
&lt;li&gt;境界を越えるデータは単純なデータ構造を使用する (エンティティオブジェクトを渡したりしない)&lt;/li&gt;
&lt;li&gt;ビジネスルールはWeb, UI, DB, フレームワークなどの外部要素と独立してテストができる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上記事項をきれいに守るためのテクニックは多岐にわたる。
クリーンアーキテクチャの図として出回っている、かの有名な同心の図も一つの具体例に過ぎない。
パッケージングの方法についても同心円図の命名規則に合わせる必要はなく、
最後に言及があるようにドメイン駆動設計を念頭に分割していく方が理にかなっていると思う
(し、これはクリーンアーキテクチャに違反しているわけでもない)。&lt;/p&gt;
&lt;p&gt;上記を満たすための設計の切り口があることと切り口にしてはいけないものがあることも学べた。
切り口は&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;アクターとユースケース (垂直方向)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アクターごとに独立して変更できるよう&lt;/li&gt;
&lt;li&gt;ユースケースがドメインオブジェクトで表現できるよう&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;レイヤーレベル (水平方向)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;であり、切り口にしてはいけないものは詳細であるフレームワークやデータベースである。&lt;/p&gt;
&lt;p&gt;クリーンアーキテクチャはドメイン駆動設計を念頭においたアーキテクチャであると私は考えているが、
用いられる用語はそれぞれで幾分か違ってしまっている。
&lt;a href=&quot;https://qiita.com/takasek/items/70ab5a61756ee620aee6&quot;&gt;お前らがModelと呼ぶアレをなんと呼ぶべきか。近辺の用語(EntityとかVOとかDTOとか)について整理しつつ考える&lt;/a&gt; にてかなり詳しくまとめてくれているので参照されたい。&lt;/p&gt;
&lt;p&gt;最後に、クリーンアーキテクチャを学んだところで設計の「正解」が判明するわけではないとわかった。
ただし、書籍に大量に記述されている原則と照らし合わせることで何が「間違えている」かの知識を多く得ることができたのではないかと感じている。
クリーンアーキテクチャを採用した設計という言葉を使っていたがこれからは避けよう。
あぁ、アーキテクチャなんもわからん。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[エリック・エヴァンスのドメイン駆動設計をまとめる]]></title><description><![CDATA[いわゆるエヴァンス本を読んだので頭の整理がしたい]]></description><link>https://dondakeshimo.github.io/tech-blog/blog/evans-eric-ddd</link><guid isPermaLink="false">https://dondakeshimo.github.ioblog/evans-eric-dddエリック・エヴァンスのドメイン駆動設計をまとめる</guid><dc:creator><![CDATA[dondakeshimo]]></dc:creator><pubDate>Tue, 18 May 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;目次 &lt;!-- exclude-toc --&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-0-0-0&quot;&gt;動機&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec2-0-0-0&quot;&gt;ドメイン駆動設計&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-1-0&quot;&gt;ドメイン駆動設計の基本的用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-2-0&quot;&gt;ユビキタス言語&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec3-0-0-0&quot;&gt;設計における構成要素&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-1-0-0&quot;&gt;アーキテクチャ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-1-1-0&quot;&gt;レイヤードアーキテクチャ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-1-2-0&quot;&gt;利口なUI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-2-0-0&quot;&gt;オブジェクト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-2-1-0&quot;&gt;ENTITIES (REFERENCE OBJECTES)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-2-2-0&quot;&gt;VALUE OBJECTS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-2-3-0&quot;&gt;SERVICES&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-3-0-0&quot;&gt;モジュール (パッケージ)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-4-0-0&quot;&gt;ライフサイクル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-4-1-0&quot;&gt;集約&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-4-2-0&quot;&gt;ファクトリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-4-3-0&quot;&gt;リポジトリ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec4-0-0-0&quot;&gt;リファクタリング&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec4-1-0-0&quot;&gt;SPECIFICATION&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec4-2-0-0&quot;&gt;設計&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec4-3-0-0&quot;&gt;デザインパターン&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec4-3-1-0&quot;&gt;STRATEGY (POLICY)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec4-3-2-0&quot;&gt;COMPOSITE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec5-0-0-0&quot;&gt;戦略的設計&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec5-1-0-0&quot;&gt;モデルの整合性維持&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec5-1-1-0&quot;&gt;境界づけられたコンテキスト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec5-1-2-0&quot;&gt;共有カーネル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec5-1-3-0&quot;&gt;顧客/提供者 (CUSTOMER/SUPPLIER)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec5-1-4-0&quot;&gt;順応者 (CONFORMIST)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec5-1-5-0&quot;&gt;腐敗防止層 (ANTICORRUPTION LAYER)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec5-1-6-0&quot;&gt;公開ホストサービス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec5-1-7-0&quot;&gt;公表された言語&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec5-2-0-0&quot;&gt;蒸留&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec5-2-1-0&quot;&gt;コアドメイン&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec5-2-2-0&quot;&gt;汎用サブドメイン&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec5-2-3-0&quot;&gt;ドメインビジョン声明文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec5-2-4-0&quot;&gt;強調されたコア&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec5-2-5-0&quot;&gt;隔離されたコア&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec5-2-6-0&quot;&gt;抽象化されたコア&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec5-3-0-0&quot;&gt;大規模な構造&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec5-3-1-0&quot;&gt;責務のレイヤ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec5-3-2-0&quot;&gt;知識レベル&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec1-0-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;動機&lt;/h1&gt;
&lt;p&gt;ソフトウェアエンジニア界で活動をしている人なら誰しもが聞いたことはあろう
&lt;a href=&quot;https://www.amazon.co.jp/%E3%82%A8%E3%83%AA%E3%83%83%E3%82%AF%E3%83%BB%E3%82%A8%E3%83%B4%E3%82%A1%E3%83%B3%E3%82%B9%E3%81%AE%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E9%A7%86%E5%8B%95%E8%A8%AD%E8%A8%88-Architects%E2%80%99Archive-%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA%E3%81%AE%E5%AE%9F%E8%B7%B5-%E3%82%A8%E3%83%AA%E3%83%83%E3%82%AF%E3%83%BB%E3%82%A8%E3%83%B4%E3%82%A1%E3%83%B3%E3%82%B9/dp/4798121967/ref=tmm_other_meta_binding_swatch_0?_encoding=UTF8&amp;#x26;qid=&amp;#x26;sr=&quot;&gt;エリック・エヴァンスのドメイン本&lt;/a&gt;
私もようやくその本の価値が分かる時分になり、手にとった。
どうやら考えていたよりも幾分実験的な内容で、体系だっているようで煩雑としている印象を受けたが、
如何せん書かれていることは設計を行う人間にとっては不可欠な内容と思える物ばかりで、
是非とも自分のものにしたいという思いからエッセンスのみを &lt;em&gt;自分のために&lt;/em&gt; まとめる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;ドメイン駆動設計&lt;/h1&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-1-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;ドメイン駆動設計の基本的用法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;モデルと設計の核心が相互に形成し合う&lt;/li&gt;
&lt;li&gt;モデルは、チームメンバ全員が使用する言語の基盤である&lt;/li&gt;
&lt;li&gt;モデルとは、蒸留された知識である&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-2-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;ユビキタス言語&lt;/h3&gt;
&lt;p&gt;ドメインエキスパートが使用する専門用語とソフトウェアエンジニアが使用する言語は共通化する必要がある。
この共通化された言語を &lt;strong&gt;ユビキタス言語&lt;/strong&gt; という。&lt;/p&gt;
&lt;p&gt;ユビキタス言語の語彙にはクラスや主要な操作の名前が含まれている。
開発チームは試行錯誤の上で、用語や用語の組み合わせがぎこちない場所を発見した場合、その代わりとなる表現を探す。
言語に対するこのような変更はドメインモデルに対する変更として認識される。
ドメインモデルは言語の骨格として使用されることになり、モデルはユビキタス言語を反映したものにならなければならない。
その上で、チーム内の全てのコミュニケーションとコードにおいて、その言語を厳格に用いることをチームに約束させることが重要である。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ユビキタス言語における変更は、モデルに対する変更であると認識すること。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;モデルが言語の骨格となるが、それに異議を唱えるのはもちろん開発チームのみでなくドメインエキスパートも同様にすべきである。
(むしろその方が多いとも思われる。)
ユビキタス言語の使いにくさ、ぎこちなさはモデルの不整合の発見の一助となる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-0-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;設計における構成要素&lt;/h1&gt;
&lt;p&gt;&lt;a id=&quot;sec3-1-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;アーキテクチャ&lt;/h2&gt;
&lt;p&gt;&lt;a id=&quot;sec3-1-1-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;レイヤードアーキテクチャ&lt;/h3&gt;
&lt;p&gt;ドメインモデルの隔離と依存関係の整理のためにレイヤードアーキテクチャが用いられる。
代表的な例としてMVCモデルが挙げられる。
本書で紹介されているレイヤーについて確認すると&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ユーザインタフェース層(プレゼンテーション層)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外部との接続部分&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;アプリケーション層&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ソフトウェアが行うべき処理を定義する&lt;/li&gt;
&lt;li&gt;ドメインオブジェクトを使用して問題を解決する&lt;/li&gt;
&lt;li&gt;ビジネスルールや知識を含まない&lt;/li&gt;
&lt;li&gt;ビジネスの状態は持たないが作業の進捗などの情報は持っても良い&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ドメイン層(モデル層)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ビジネスの概念とビジネスの状態、ルールを管理する&lt;/li&gt;
&lt;li&gt;状態の永続化などの技術的詳細はインフラストラクチャ層に委譲する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;インフラストラクチャ層&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ドメイン層だめの永続化、ユーザインタフェースのウェジェット描画など技術的詳細を提供する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本書におけるレイヤードアーキテクチャの本質はドメインモデルの隔離に尽きると言える。
ドメイン層を技術的詳細やその他詳細と疎結合にすることで、ドメインモデルはドメインモデルのみに集中することができる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-1-2-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;利口なUI&lt;/h3&gt;
&lt;p&gt;上記のドメインモデルに集中する本懐を鑑みると表題はおかしな言葉に見えるし、
実際ドメイン駆動設計において、利口なUIはアンチパターンである。
しかし、フロントエンド開発の現状を考えるとしっかりとその長短について見つめ直す必要があろう。
もちろん複雑なビジネスロジックを含むフロントエンド開発においては単なるUIとしての機能というよりは、
それ一つでソフトウェアとみなせるため、内部でドメイン駆動設計を行うという選択肢もあるが、
ここでいうUIとは最も外部に位置するクラスであり、
ReactでいうpageごとのMainコンポーネントがそれに当たると考えて良いと思われる。&lt;/p&gt;
&lt;h5&gt;利点&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;単純なアプリケーションの場合&lt;/strong&gt; 、生産性が高くすぐに作れる&lt;/li&gt;
&lt;li&gt;アーキテクチャに対する造詣が浅くても問題ない&lt;/li&gt;
&lt;li&gt;単純な機能追加は簡単で、見積もりも簡単である&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;欠点&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;アプリケーションの統合は困難である&lt;/li&gt;
&lt;li&gt;振る舞いの再利用が難しい&lt;/li&gt;
&lt;li&gt;複雑な機能追加を行うとアプリケーションもまた複雑化していく&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec3-2-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;オブジェクト&lt;/h2&gt;
&lt;p&gt;&lt;a id=&quot;sec3-2-1-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;ENTITIES (REFERENCE OBJECTES)&lt;/h3&gt;
&lt;p&gt;同一性によって定義されるオブジェクトのことをエンティティと呼ぶ。
エンティティは属性よっては定義されず、同じ属性を保有していても他のオブジェクトと区別される必要があり、
属性が変化したとしても同一性が損なわれてはならない。&lt;/p&gt;
&lt;p&gt;エンティティの考え方として代表的なものを考えると「人間」という概念が挙げられる。
身長体重などの属性はいくらでも変化するが私が私であることは変わらない(本当かは正直知らないが)。&lt;/p&gt;
&lt;p&gt;モデルでエンティティを定義する際に留意することを下記に示す。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一性を第一とすること&lt;/li&gt;
&lt;li&gt;クラスの定義をシンプルに保ち、ライフサイクルの連続性と同一性に集中すること&lt;/li&gt;
&lt;li&gt;形式や履歴に関係なく、各オブジェクトを識別する手段を定義すること&lt;/li&gt;
&lt;li&gt;オブジェクト同士を属性によって突き合わせる要件には注意すること&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各オブジェクトに対して結果が保証される操作を定義すること&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ユニークな文字列が代表的な解決策ではある&lt;/li&gt;
&lt;li&gt;ユニークな文字列を使用するか否かにかかわらず、モデルが同じであるとは何を意味するかを定義する必要がある&lt;/li&gt;
&lt;li&gt;一度識別子を決定したら決して変更してはならない&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec3-2-2-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;VALUE OBJECTS&lt;/h3&gt;
&lt;p&gt;あるモデル要素についてその属性にのみ関心が集中し、同一性が必要ないオブジェクトを値オブジェクトと呼ぶ。
エンティティと異なり、同じ属性を保有しているオブジェクト同士に区別は必要なく同一のものであると見なす。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一性を与えない&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不変なモデルとして設計する&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FLYWEIGHTパターンなど考慮が非常に楽である&lt;/li&gt;
&lt;li&gt;ただし多くの言語でサポートされている概念ではないので開発ルールとして開発者が遵守する必要がある&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;値オブジェクトに対して可変性を持たせる場合もあるが、可能ならば回避する性質である。
可変性が生じた場合はその値オブジェクトは共有してはならない。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-2-3-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;SERVICES&lt;/h3&gt;
&lt;p&gt;ドメインエキスパートとの会話から生まれる概念の中には、本質的に活動や行動、操作であって、
オブジェクトとしてモデル化すると不自然なものがある。
これらの概念は無理にオブジェクトとしてモデル化せずドメインサービスとしてモデル化することができる。
サービスとは、モデルにおいて独立したインタフェースとして提供される操作であり、カプセル化されない。
良く設計されたサービスの特徴として&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作がドメインの概念に関係しており、その概念がドメインオブジェクトの自然な一部ではない&lt;/li&gt;
&lt;li&gt;引数と返り値、つまりインタフェースはドメインオブジェクトで定義されている&lt;/li&gt;
&lt;li&gt;操作に状態がない&lt;/li&gt;
&lt;li&gt;ユビキタス言語で操作名が定義されている&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;それぞれのレイヤーに属するサービスを
ドメインサービス、アプリケーションサービス、インフラストラクチャサービスと呼ぶことができる。&lt;/p&gt;
&lt;p&gt;ドメイン層にサービスを導入することで、アプリケーション層によるドメイン層の呼び出し処理が簡素化され、
ドメイン層とアプリケーション層の線引きを明確化することができる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-3-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;モジュール (パッケージ)&lt;/h2&gt;
&lt;p&gt;モジュール間では低結合、モジュール内では高凝集と言うのは技術的に考えて自明の理だが、
モジュールは概念についても分断してしまうことを意識する。
モジュールはユビキタス言語を用いて名付けられるべきであり、
ドメインの概念に従って分割されると同時に対応するコードも独立される状態を目指す。&lt;/p&gt;
&lt;p&gt;フレームワークにただ従ってパッケージングを行った場合、上述のような結果が得られないことも多いので注意する。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-4-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;ライフサイクル&lt;/h2&gt;
&lt;p&gt;&lt;a id=&quot;sec3-4-1-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;集約&lt;/h3&gt;
&lt;p&gt;集約は複数オブジェクトの集まりを指す言葉であり、トランザクションの単位となる。
特に複数のオブジェクトに関連する不変条件が存在する時に、シンプルなロックの機構をやたらと使うと
過度に遅いシステムや、デッドロックが発生するシステムが作成されてしまうため、
いくつかのオブジェクト間の不変条件を満たすことを容易にするようにグルーピングしたものが集約となる。&lt;/p&gt;
&lt;p&gt;集約において重要な概念は集約ルートと境界である。
集約ルートとはグローバルな同一性を保持したエンティティであり、外部からの参照を受け付ける集約内部で唯一のオブジェクトとなる。
境界とは集約内部においてはルートエンティティ以外の参照を持つことは自由だが、集約外部で参照を持たれて良いのは
ルートエンティティのみと言う約束および内部と外部の境目を指す。&lt;/p&gt;
&lt;p&gt;トランザクションの具体的なルールは下記のようになる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集約のルートエンティティは、グローバルな同一性をもち、不変条件をチェックする最終的な責務を負う&lt;/li&gt;
&lt;li&gt;境界内部のエンティティは、集約ないのでのみ一意となるローカルな同一性を持つ&lt;/li&gt;
&lt;li&gt;集約の境界外にあるオブジェクトはルートエンティティ以外の境界内のオブジェクト参照を保持できない&lt;/li&gt;
&lt;li&gt;ルートエンティティは境界内部のオブジェクトの参照を返却できるが、境界外部のオブジェクトはその参照を保持してはならない&lt;/li&gt;
&lt;li&gt;上記のルールを満たした場合、データベースから直接取得できるのは集約ルートだけとなる&lt;/li&gt;
&lt;li&gt;削除操作については境界内部に存在するオブジェクトを一度に削除する必要がある&lt;/li&gt;
&lt;li&gt;境界内部に存在するオブジェクトに対する変更が反映される際、必ず集約全体の不変状態を満たすようにしなければならない&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この概念を直接的に用いると言うことは少ないかもしれないが、
ファクトリとリポジトリにおいて対象となるものがここで述べた &lt;strong&gt;集約&lt;/strong&gt; となる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-4-2-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;ファクトリ&lt;/h3&gt;
&lt;p&gt;オブジェクトのライフサイクルにおいて初期の生成時、または中期の再構成に利用される。
オブジェクトを利用するクライアントに対して、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;オブジェクトの関連の詳細まで意識させたくない&lt;/li&gt;
&lt;li&gt;オブジェクトの生成に必要な複雑な操作を行わせたくない&lt;/li&gt;
&lt;li&gt;多態的に利用されるオブジェクト群のアクセスポイントを特定させたい&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上記のような要望がある場合はファクトリを利用する。&lt;/p&gt;
&lt;h5&gt;ファクトリの配置場所&lt;/h5&gt;
&lt;p&gt;対象が集約である場合(これがほとんどの場合であると著者は述べている)、エンティティルートにファクトリメソッドを追加することができる。&lt;/p&gt;
&lt;p&gt;別の例としては、集約の境界外であるが対象オブジェクトを生成する際に支配的なルールを内包しているオブジェクトが
ファクトリメソッドを持つことも自然な設計である。&lt;/p&gt;
&lt;p&gt;また、上記のどちらも自然な設計とは思えない場合は独立したファクトリオブジェクトまたはファクトリサービス
(どちらも同じものだと思われる)を作成すると言う選択肢も忘れていはならない。&lt;/p&gt;
&lt;h5&gt;ファクトリのインタフェース&lt;/h5&gt;
&lt;p&gt;以下の点を念頭において、シグネチャを決定する必要がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;各操作はアトミックであり、一度のやり取りで完結する&lt;/li&gt;
&lt;li&gt;失敗時の挙動については事前に取り決めをしておき一貫性を保つ&lt;/li&gt;
&lt;li&gt;ファクトリはその引数と結合する&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特に引数との結合だが、引数として適切なものは&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下位の設計層に由来する基本的なオブジェクト&lt;/li&gt;
&lt;li&gt;密接に関連する(関連せざるを得ない)抽象オブジェクト&lt;/li&gt;
&lt;li&gt;生成物に付与する設定項目&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;不変条件の管理&lt;/h5&gt;
&lt;p&gt;ファクトリを使用する場合、生成物の不変条件の管理をファクトリで行うか生成物で行うかの選択に迫られる。
多くの場合、生成されるオブジェクトに不変条件のロジックを記述し、
ファクトリは不変条件の担保を生成オブジェクトに委譲させる形を取れば十分である。
ただし、下記のような条件の場合はファクトリにロジックを移動させることも可能である。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不変条件のロジックが必要なタイミングがオブジェクト生成時のみである&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;値オブジェクト&lt;/li&gt;
&lt;li&gt;エンティティの識別子&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;集約のルールに関するロジック&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;オブジェクトの再構成&lt;/h5&gt;
&lt;p&gt;ファクトリをライフサイクル初期の生成に関する操作を扱うものとして見てきたが、オブジェクトの再構成にもファクトリを利用することがある。
生成に対して再構成を行う場合はより複雑な操作が必要になる場合があるため注意が必要である。
また、生成とは2つの点で大きく異なる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;エンティティのファクトリに関して、新しい追跡IDを割り当てることがない&lt;/li&gt;
&lt;li&gt;不変条件の違反に対して生成時とは別の制御を行う必要がある場合が多い&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;まとめ&lt;/h5&gt;
&lt;p&gt;インスタンスの生成のアクセスポイントは何かしら必要である、それがコンストラクタであることもあるが、
ファクトリを作成することで複雑な操作や実装の詳細の隠蔽を行えるなどの多大な恩恵を得られることがある。
ファクトリはモデルを表現するものではないが、ドメイン設計の一部であり、モデルを表現するオブジェクトを鮮明にしておく上で役に立つ。
モデルの一部ではないが、モデルの詳細を知っているアクセスポイントであるため、
下手な依存関係や密結合を作成しないことや不変条件に対しる責務に対して慎重に設計する必要がある。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-4-3-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;リポジトリ&lt;/h3&gt;
&lt;p&gt;オブジェクトの再構成において、グローバルに検索を用いてアクセスできるデータベースは非常に有用だが、
その疎結合せいやグローバル性からドメインオブジェクトや集約ルートが無視されてしまう可能性が残る。
そのため、ほとんどのオブジェクトではグローバルな検索でアクセスすべきではない。&lt;/p&gt;
&lt;p&gt;グローバルな検索によって再構成されるべきオブジェクトももちろんある。
ただし、クライアントが自由に検索クエリをかけるような状況、あるいは検索における技術的な枠組みを直接扱うような状況に
陥っている場合、先述のビジネスルールの無視や境界の無視が起こりかねない。
そのため、クライアントとデータへのアクセス技術との間に &lt;strong&gt;リポジトリ&lt;/strong&gt; を挟むことでクライアントのアクセスポイントを限定する。
その他にもリポジトリを用意することによる恩恵は多数ある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;クライアントにとって再構成の処理がシンプルになる&lt;/li&gt;
&lt;li&gt;アプリケーションとドメインの設計を永続化技術や複数のデータベース戦略などから分離する&lt;/li&gt;
&lt;li&gt;オブジェクトアクセスに関する設計上の決定を伝える&lt;/li&gt;
&lt;li&gt;テストで使用するために、ダミーの実装で置き換えるのが容易になる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec4-0-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;リファクタリング&lt;/h1&gt;
&lt;p&gt;&lt;a id=&quot;sec4-1-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;SPECIFICATION&lt;/h2&gt;
&lt;p&gt;あるオブジェクトが何らかの基準を満たしているかどうかを判定する述語的な値オブジェクトを仕様オブジェクトという。
仕様オブジェクトを用いることはある種のパターンである。&lt;/p&gt;
&lt;p&gt;ビジネスルールの中にはどのエンティティ、値オブジェクトの責務にも合致しないものがあり、それらを強引にオブジェクトに含ませることで、
ドメインオブジェクト本来の意味を侵害しかねない。こうした際に仕様オブジェクトとしてビジネスルールを分離することで、
ドメインオブジェクトが保護され、モデルの保守性、表現力が増す。
仕様の価値は異なるように見えるアプリケーションの機能を統一することにある。
下記のうち一つでも当てはまる用途があればオブジェクトの状態を定義する必要がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;オブジェクトを &lt;strong&gt;検証&lt;/strong&gt; して何らかの要求を満たしているか、何らかの目的のための用意ができているか調べる&lt;/li&gt;
&lt;li&gt;コレクションからオブジェクトを &lt;strong&gt;選択&lt;/strong&gt; する&lt;/li&gt;
&lt;li&gt;何らかの &lt;strong&gt;要求&lt;/strong&gt; に適合する新しいオブジェクトの生成を定義する&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上記の検証、選択、要求に応じた構築という3つの用途を仕様というパターンに当てはめることで、同一のルールとして扱うことができる。&lt;/p&gt;
&lt;h5&gt;検証&lt;/h5&gt;
&lt;p&gt;非常に単純な用途であり、作成された仕様オブジェクトは渡された対象オブジェクトが仕様オブジェクトに記述されている
ビジネスルールを満たしているかどうかを確認する。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;DelinquentInvoiceSpecification&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;InvoiceSpecification&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 当日日付&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Date&lt;/span&gt; currentData&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;DelinquentInvoiceSpecification&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Date&lt;/span&gt; currentDate&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;currentDate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; currentDate&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;isSatisfiedBy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Invoice&lt;/span&gt; candidate&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; gracePeriod &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; candidate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;customer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getPaymentGracePeriod&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;Date&lt;/span&gt; firmDeadline &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;DateUtility&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addDaysToDate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;candidate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;dueDate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; gracePeriod&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; currentDate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;firmDeadline&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;また、仕様を述語的に扱うのを容易にするためにコンポジットパターンを適用することも可能である。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Specification&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;isSatisfiedBy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; candidate&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token class-name&quot;&gt;Specification&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;and&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Specification&lt;/span&gt; other&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token class-name&quot;&gt;Specification&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;or&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Specification&lt;/span&gt; other&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token class-name&quot;&gt;Specification&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;not&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;AbstractSpecification&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Specification&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Specification&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;and&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Specification&lt;/span&gt; other&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;AndSpecification&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; other&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Specification&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;or&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Specification&lt;/span&gt; other&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;OrSpecification&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; other&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Specification&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;not&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;NotSpecification&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;選択&lt;/h5&gt;
&lt;p&gt;検証と同様に選択における条件を仕様オブジェクトに記述する。
例えば、上記の &lt;code class=&quot;language-text&quot;&gt;DelinquentInvoiceSpecification&lt;/code&gt; に &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Set&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;selectSatisfying&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;InvoiceSpecification&lt;/span&gt; spec&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;を追加すれば良いだろう。&lt;/p&gt;
&lt;p&gt;ここで留意する必要があるのは、インフラストラクチャ層の責務である技術的詳細をドメイン層に持ち込まないことである。
逆にビジネスルールをインフラストラクチャ層に流出させないことも同様に重要である。
O/Rマッパーを使用するかダブルディスパッチを利用するなどして、レイヤを保つこと。&lt;/p&gt;
&lt;h5&gt;要求&lt;/h5&gt;
&lt;p&gt;検証、選択が既に存在するオブジェクトに対する仕様であったが、要求は今から生成するオブジェクトに対する仕様である。
このオブジェクトを満たすように生成や再構築が行われることとなる。&lt;/p&gt;
&lt;p&gt;同様の事象が扱えるパターンとしてジェネレータがあり、こちらを使用することで受ける恩恵もいくつかあるので
トレードオフを吟味して考える必要がある。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec4-2-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;設計&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;意図の明白なインタフェース&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;副作用のない関数&lt;/li&gt;
&lt;li&gt;表明: 操作の事後条件とクラスと集約の不変条件の宣言&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;概念の輪郭&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;独立したクラス&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;閉じた操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec4-3-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;デザインパターン&lt;/h2&gt;
&lt;p&gt;&lt;a id=&quot;sec4-3-1-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;STRATEGY (POLICY)&lt;/h3&gt;
&lt;p&gt;プロセスの中で変化する部分を柔軟に変更するためにストラテジーパターンが有効である。
先述の仕様オブジェクトはStrategyパターンとして扱うことが可能である。&lt;/p&gt;
&lt;p&gt;書籍の具体例を借りると、運搬業務における経路選択において何を最適化するかの仕様を可変部分としてStrategyパターンを組むことができる。
この場合、経路選択内では仕様を満たすような経路を探すという作業に集中することができ、
選択されるべき経路が最も安い経路なのか、最も早い経路なのかなどは考えなくてよくなる。
選択の仕様を分離することでシステムに柔軟性が生まれていることがわかる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec4-3-2-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;COMPOSITE&lt;/h3&gt;
&lt;p&gt;ネストされたコンテナの関係性をモデルに反映する場合コンポジットパターンが有効である。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec5-0-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;戦略的設計&lt;/h1&gt;
&lt;p&gt;&lt;a id=&quot;sec5-1-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;モデルの整合性維持&lt;/h2&gt;
&lt;p&gt;&lt;a id=&quot;sec5-1-1-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;境界づけられたコンテキスト&lt;/h3&gt;
&lt;p&gt;モデルが適用されるコンテキストは明確に定義されなければならない。
明示的な境界は、チーム編成、アプリケーションのようと、コードベースやデータベーススキーマなどの物理的な表現などの観点から設定する。
コンテキストの名前は当然ユビキタス言語である必要がある。
モデルに詳しくない人が誤って他のコンテキストの概念を直接扱ったりすることのないように、
コンテキストマップに代表されるドキュメントがあると良い。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec5-1-2-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;共有カーネル&lt;/h3&gt;
&lt;p&gt;コンテキストの境界を跨ぐ概念などはそれぞれのコンテキストを担当するチーム間で合意を得て開発していく必要がある。
これらの概念をドメインモデルのサブセットとして共有する手法がある。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec5-1-3-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;顧客/提供者 (CUSTOMER/SUPPLIER)&lt;/h3&gt;
&lt;p&gt;二つのシステム間の関係が「上流」と「下流」の関係にある場合、変更に対するオーバーヘッドが生じる場合がある。
上流のチームは下流のチームに必要だったものを止めてしまわないかと慎重になり、
下流のチームは上流のチームが新たな情報を与えてくれないとプロジェクトが進まないことがある。
この場合は、顧客/提供者の関係であることを明示的な関係性として定義すること。
上流チームのシステムで下流チームに関係のある部分は下流チームと共同でテストを作成し(受入テスト)、
継続的な統合の一部として実行するようにする。
また、提供者にとって優先されるべきは顧客であるということも取り決める必要がある。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec5-1-4-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;順応者 (CONFORMIST)&lt;/h3&gt;
&lt;p&gt;上流/下流関係の2チームがあったとして先述のように顧客/提供者の関係を築くには上流側に恩恵がない場合、
下流チームはどうすることもできない。
上記のような時は下流チームが上流チームに隷属する他ない。
このような下流システムを順応者と呼んでいる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec5-1-5-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;腐敗防止層 (ANTICORRUPTION LAYER)&lt;/h3&gt;
&lt;p&gt;コンテキストの境界におけるインタフェースが膨大になると、コンテキスト内のモデルがインタフェースに合わせてしまうことがある。
インタフェースはモデルに従属されるべきであり、これはおかしい。
この場合は、インタフェースを用のレイヤを作成することで、ドメインモデルを保護する。
このレイヤを腐敗防止層と呼ぶ。&lt;/p&gt;
&lt;p&gt;腐敗防止層はファサードバターンとアダプタパターンを合わせて使用することができる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec5-1-6-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;公開ホストサービス&lt;/h3&gt;
&lt;p&gt;システム間の関係として、基本的にはサーバーがクライアントの要求に応えるようにインタフェースを定義するが、
クライアントが多い場合などクライアントの要望に応えるのが難しい場合はサーバー側の主導でインタフェースを定める。
サーバはアクセするためのプロトコルを定義し公開する。この共有プロトコルは一貫性のある状態に保つ必要がある。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec5-1-7-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;公表された言語&lt;/h3&gt;
&lt;p&gt;二つのコンテキスト間でモデルをやり取りするには共通の言語が必要になる。
必要なドメインの情報を公表された共通の媒体を通じて交換するのが良い。
例えば、化学マークアップ言語(CML: Chemical Markup Language) などがそれにあたる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec5-2-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;蒸留&lt;/h2&gt;
&lt;p&gt;蒸留とは混ざり合ったコンポーネントを分離するプロセスであり、価値があって役立つ形式で本質を抽出するためのものである。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec5-2-1-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;コアドメイン&lt;/h3&gt;
&lt;p&gt;ドメインモデルの中でも最も重要なコアドメインを明確にし位置付けることで、開発の優先順位や外部委託の判断などの判断基準となる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec5-2-2-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;汎用サブドメイン&lt;/h3&gt;
&lt;p&gt;ドメインモデルの中で専門的な知識を捉えることも伝えることもなく、複雑さを付け加えるだけの部分もある。
このようなサブドメインを識別し分離することで、コアドメインに対してより集中できるようになる。
また、専門的な知識に携わっていない部分に関しては汎用性が高い部分ともいえるため、
既製品や公表されているモデルの採用も視野に入れられる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec5-2-3-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;ドメインビジョン声明文&lt;/h3&gt;
&lt;p&gt;コアドメインとそれがもたらす価値に関する簡潔な記述を作成することで、「価値の提議」を行える。
ドメインモデルがどのように役立ち、対象のアクターに対してそれぞれどのような対応を行うかを示す。
スコープはコンテキスト内のスコープに限定する。
この声明文はプロジェクトの早期に作成し、新しい洞察を得たら都度改訂すること。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec5-2-4-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;強調されたコア&lt;/h3&gt;
&lt;p&gt;ドメインビジョン声明文は広い観点から見た提議であり、具体性に乏しい。
開発者にとってコアドメインはドメインビジョン声明文のような抽象的な状態で言語化されているだけでは十分ではない。
そこで、コアドメインとコアを構成する要素感の主要な相互作用を記述した &lt;strong&gt;蒸留ドキュメント&lt;/strong&gt; を記載する。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec5-2-5-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;隔離されたコア&lt;/h3&gt;
&lt;p&gt;コアドメインは洗練され、独立している状態にある必要がある。
このためには如何様な開発コストも割くべきである。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec5-2-6-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;抽象化されたコア&lt;/h3&gt;
&lt;p&gt;モデルにおける最も根本的な概念を抽出し、それを抽象クラスやインタフェースにくくり出す。
コアドメインを洗練できたとしても、膨大な詳細に圧倒されるような設計では理解することは難しい。
抽象化の層を挟むことで階層的に理解が進むようになる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec5-3-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;大規模な構造&lt;/h2&gt;
&lt;p&gt;&lt;a id=&quot;sec5-3-1-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;責務のレイヤ&lt;/h3&gt;
&lt;p&gt;モデル間の概念状の依存関係、ドメインの様々な部分の変更の大きさと頻度を元に、ドメインの自然な階層を探す。
階層に従い、抽象的な責務を割り当てる。
概念的依存関係として下表のような金融システムの例をあげる。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;レイヤ&lt;/th&gt;
&lt;th&gt;概念&lt;/th&gt;
&lt;th&gt;状態&lt;/th&gt;
&lt;th&gt;具体例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;意思決定&lt;/td&gt;
&lt;td&gt;分析メカニズム&lt;/td&gt;
&lt;td&gt;状態変化はほとんどない&lt;/td&gt;
&lt;td&gt;リスク分析、交渉ツール&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ポリシー&lt;/td&gt;
&lt;td&gt;戦略、制約&lt;/td&gt;
&lt;td&gt;遅い状態変化&lt;/td&gt;
&lt;td&gt;準備金の限度、資産配分目標&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;確約 ｜ビジネス取引と顧客の契約&lt;/td&gt;
&lt;td&gt;ボチボチな状態変化&lt;/td&gt;
&lt;td&gt;顧客合意、シンジケート合意&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;業務&lt;/td&gt;
&lt;td&gt;ビジネスの現実&lt;/td&gt;
&lt;td&gt;早い状態変化&lt;/td&gt;
&lt;td&gt;未払いローンの状態、支払いと配分&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a id=&quot;sec5-3-2-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;知識レベル&lt;/h3&gt;
&lt;p&gt;エンティティ間にある役割と関係が状況によって変わるアプリケーションでは複雑さがます。
例えば従業員とその役割などが当てはまる。
リフレクションパターンにおけるベースモデルを業務レベル、メタレベルを知識レベルとすることで
ドメインモデルに適用したものを使うと複雑さを軽減できる。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[GitHub ActionsでCHANGELOG駆動Release]]></title><link>https://dondakeshimo.github.io/tech-blog/blog/github-actions-changelog</link><guid isPermaLink="false">https://dondakeshimo.github.ioblog/github-actions-changelogGitHub ActionsでCHANGELOG駆動Release</guid><dc:creator><![CDATA[dondakeshimo]]></dc:creator><pubDate>Sun, 07 Mar 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;目次 &lt;!-- exclude-toc --&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-0-0-0&quot;&gt;概要&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec2-0-0-0&quot;&gt;手法&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-1-0&quot;&gt;CHANGELOG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-2-0&quot;&gt;Action定義ファイル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec2-0-3-0&quot;&gt;ポイント&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-3-1&quot;&gt;基本戦略&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-3-2&quot;&gt;git fetch --unshallow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-3-3&quot;&gt;outputs と &lt;code class=&quot;language-text&quot;&gt;*&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-3-4&quot;&gt;課題&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-0-0-0&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec1-0-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;概要&lt;/h1&gt;
&lt;p&gt;GitHub Actionsというサービスがある。
サービス自体の説明についてはここでは触れない。
本ポストのテーマはタイトルの通り、CHANGELOGを用いたリリースおよびタグの管理だ。&lt;/p&gt;
&lt;p&gt;タグがpushされたタイミングで、それまでのcommitを自動で読み取りCHANGELOG.mdおよびReleaseを発行してくれるという
至れり尽くせりなGitHub Actionsの例は各所で見受けられるが、
正直自分としてはcommitログそのままReleaseに書かれるとか嫌だし、
tagをpushするよりもReleaseの履歴がわかりやすくあってほしい。
要するに、tagが発行されたタイミングではなくCHANGELOGを修正したタイミングで、
CHANGELOGに応じた諸々のリリースフローを行ってほしいわけである。&lt;/p&gt;
&lt;p&gt;まとめると&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CHANGELOG.mdが修正されたcommitがmasterにpushされたタイミングでActionが起動&lt;/li&gt;
&lt;li&gt;CHANGELOG.mdに記載されているVersionのtagを発行&lt;/li&gt;
&lt;li&gt;CHANGELOG.mdに記載されている内容のReleaseを発行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;というGitHub Actionsを作るぞという話。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;手法&lt;/h1&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-1-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;CHANGELOG&lt;/h3&gt;
&lt;p&gt;下記のようなCHANGELOG.mdを想定している。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;## Version 0.1.0
* akanechan kawaii yatta-
* add choco mint ices

## Version 0.0.2
* fix release flow

## Version 0.0.1
* initial application version&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-2-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Action定義ファイル&lt;/h3&gt;
&lt;p&gt;上記のCHANGELOG.mdに対してのAction定義ファイル。
&lt;code class=&quot;language-text&quot;&gt;Extract CHANGELOG&lt;/code&gt; stepを適当にいじれば大体のCHANGELOG.mdの書き方に対応できると思われる。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;yaml&quot;&gt;&lt;pre class=&quot;language-yaml&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;&lt;span class=&quot;token key atrule&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Release

&lt;span class=&quot;token key atrule&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;token key atrule&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token key atrule&quot;&gt;branches&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; master &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token key atrule&quot;&gt;paths&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;CHANGELOG.md&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;token key atrule&quot;&gt;jobs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;

  &lt;span class=&quot;token key atrule&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token key atrule&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Release
    &lt;span class=&quot;token key atrule&quot;&gt;runs-on&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; ubuntu&lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt;latest
    &lt;span class=&quot;token key atrule&quot;&gt;steps&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;

    &lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token key atrule&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Check out
      &lt;span class=&quot;token key atrule&quot;&gt;uses&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; actions/checkout@v2

    &lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token key atrule&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Extract CHANGELOG
      &lt;span class=&quot;token key atrule&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; versioning
      &lt;span class=&quot;token key atrule&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;token scalar string&quot;&gt;
        VERSION=$(head -1 CHANGELOG.md | sed -e &apos;s/^.*Version //g&apos;)
        git fetch --prune --unshallow
        PRETAG=$(git describe --tags --abbrev=0)
        git diff $PRETAG..${{ github.sha }} -- CHANGELOG.md | grep -E &apos;^\+&apos; | grep -v &apos;+++&apos; | sed -e &apos;s/^\+//g&apos; &gt; diff-changelog.txt
        echo ::set-output name=version::$VERSION&lt;/span&gt;

    &lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token key atrule&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Tag
      &lt;span class=&quot;token key atrule&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; tag_version
      &lt;span class=&quot;token key atrule&quot;&gt;uses&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; mathieudutour/github&lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt;tag&lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt;action@v5.2
      &lt;span class=&quot;token key atrule&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;token key atrule&quot;&gt;custom_tag&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; $&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; steps.versioning.outputs.version &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token key atrule&quot;&gt;github_token&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; $&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; secrets.GITHUB_TOKEN &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token key atrule&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Release
      &lt;span class=&quot;token key atrule&quot;&gt;uses&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; softprops/action&lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt;gh&lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt;release@v1
      &lt;span class=&quot;token key atrule&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;token key atrule&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;token scalar string&quot;&gt;
          CHANGELOG.md
          LICENSE&lt;/span&gt;
        &lt;span class=&quot;token key atrule&quot;&gt;tag_name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; $&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; steps.tag_version.outputs.new_tag &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token key atrule&quot;&gt;body_path&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; diff&lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt;changelog.txt
      &lt;span class=&quot;token key atrule&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;token key atrule&quot;&gt;GITHUB_TOKEN&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; $&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; secrets.GITHUB_TOKEN &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-3-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;ポイント&lt;/h3&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-3-1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;基本戦略&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1行目の文字列から &lt;code class=&quot;language-text&quot;&gt;Version&lt;/code&gt; 以降の文字列を抽出しversionとする&lt;/li&gt;
&lt;li&gt;前回のtagとの差分をReleaseのdescriptionとする&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-3-2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;git fetch --unshallow&lt;/h4&gt;
&lt;p&gt;GitHub Actionsを使用していれば大概の場合使うであろう &lt;code class=&quot;language-text&quot;&gt;actions/checkout&lt;/code&gt; actionだが、
こちらでcloneしているリポジトリは &lt;em&gt;shallow repository&lt;/em&gt; である。
履歴情報がないので、そのままでは &lt;code class=&quot;language-text&quot;&gt;git diff&lt;/code&gt; やら &lt;code class=&quot;language-text&quot;&gt;git describe --tags&lt;/code&gt; をしても空振りに終わってしまう。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;git fetch --unshallow&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;をしてあげることで過去の変更履歴を取得して、前回のtagからの変更履歴が参照できるようにする。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-3-3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;outputs と &lt;code class=&quot;language-text&quot;&gt;*&lt;/code&gt;&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;echo ::set-output name=version::$VERSION&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;という構文を用いれば、stepから情報を出力できる。
基本的にはこの手法を用いてstep間で情報の授受をすれば問題ないと思われる。&lt;/p&gt;
&lt;p&gt;しかし、CHAGELOGの情報をoutputsに宣言した際、 &lt;code class=&quot;language-text&quot;&gt;*&lt;/code&gt; がファイル名に展開されてしまっていた。
いまいち原因は調べきれていないので、詳しい方いたら理由を教えていただけると幸いである。&lt;/p&gt;
&lt;p&gt;対応策として、CHANGELOGの差分情報はファイルに書き出して、ファイル経由で情報の伝播を行うようにした。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-3-4&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;課題&lt;/h4&gt;
&lt;p&gt;validation等は一切していないので、1行目が前と同じversionの状態でmasterへマージしてしまったりすると、
tagの上書きが発生してしまうと思われるのでCHANGELOGの修正には注意が必要。(一敗)&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-0-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;まとめ&lt;/h1&gt;
&lt;p&gt;CHANGELOGの修正をトリガーとし、CHANGELOGの内容に従ったtagとReleaseを発行することができた。
tagやReleaseの発行は外部Actionを使用しており、正直どこまで外部Actionに頼っていいかは疑問だし、不安の種でもある。
まあ、GitHub自体が破壊的なAPIの変更等を加えない限り同様のバージョンを使い続けていれば不慮の事故は起こらないと信じたい。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[デザインパターンについてまとめる]]></title><description><![CDATA[JAVA言語で学ぶデザインパターン入門を読んだのでざっくりまとめる]]></description><link>https://dondakeshimo.github.io/tech-blog/blog/design-pattern</link><guid isPermaLink="false">https://dondakeshimo.github.ioblog/design-patternデザインパターンについてまとめる</guid><dc:creator><![CDATA[dondakeshimo]]></dc:creator><pubDate>Mon, 21 Dec 2020 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;目次 &lt;!-- exclude-toc --&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec1-0&quot;&gt;デザインパターン&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-1&quot;&gt;Iterator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-2&quot;&gt;Adapter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-3&quot;&gt;Template Method&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-4&quot;&gt;Factory Method&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-5&quot;&gt;Singleton&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-6&quot;&gt;Prototype&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-7&quot;&gt;Builder&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-8&quot;&gt;Abstract Factory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-9&quot;&gt;Bridge&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-10&quot;&gt;Strategy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-11&quot;&gt;Composite&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-12&quot;&gt;Decorator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-13&quot;&gt;Visitor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-14&quot;&gt;Chain of Responsibility&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-15&quot;&gt;Facade&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-16&quot;&gt;Mediator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-17&quot;&gt;Observer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-18&quot;&gt;Memento&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-19&quot;&gt;State&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-20&quot;&gt;Flyweight&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-21&quot;&gt;Proxy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-22&quot;&gt;Command&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-23&quot;&gt;Interpreter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec1-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;デザインパターン&lt;/h1&gt;
&lt;p&gt;&lt;a id=&quot;sec1-1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Iterator&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; arr&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arr&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上記のような基本的なループは集合体のスキャンを行っている。
上記において一時変数 &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt; の働きを抽象化し、一般化したものをIteratorパターンと呼ぶ。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;Iterator&lt;/span&gt; it &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SampleAggregate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;it&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;Sample&lt;/span&gt; sample &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Sample&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;it&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sample&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Iteratorインタフェースによって終了条件と「次」の要素の抽出を抽象化している。
このことで、Sampleクラスの実装とスキャンを独立させることができている。
SampleAggregateがどのようなコンテナを使用しても上記のコードに手を加える必要がない。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Adapter&lt;/h2&gt;
&lt;p&gt;「すでに提供されているもの」と「必要なもの」のズレを埋めるためのデザインパターン。
知られている実装方法として継承を用いたものと以上を用いたものがある。
「すでに提供されているもの」をTarget、「必要なもの」をAdaptee、「ズレを埋めるもの」をAdapterとする。&lt;/p&gt;
&lt;h5&gt;継承を用いたパターン&lt;/h5&gt;
&lt;p&gt;Targetをインターフェースとしたパターン。
この場合、単一継承のみ可能なJavaでもAdapteeを継承できる。
特にひねりもなくAdapterパターンを使用する時はこちらのパターンで十分と考えられる。
Adapterの宣言が下記のようになる。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Adapter&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Adaptee&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Target&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;委譲を用いたパターン&lt;/h5&gt;
&lt;p&gt;Targetをクラスとしたパターン。
Targetにstatic functionが必要な場合や、Adapteeを継承すると可読性が落ちるような場合は
Adapteeを委譲することでAdapterパターンを使用することができる。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Adapter&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Target&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Adaptee&lt;/span&gt; adaptee&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;targetFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        adaptee&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;既にある十分に時の試練に耐えた実用的なクラスがあった時、そのクラスを利用したいと考えるのは自然である。
その際に、既にあるクラスと今必要なメソッドの小さなズレを解消するために
既にあるクラスを修正してしまった場合、既にあるクラスはまた十分なテストを行う必要が生まれる。
Adapterパターンを用いて既にあるクラスに何も手を加えずに利用した場合は、何かバグが発生しても基本的には
Adapter, Targetのみを疑えば良いことになる。
また、互換性を生み出す際にもAdapterパターンを使用することは有用であり、
この場合は旧バージョンにAdapterパターンを適用することでVersionが異なりインターフェースが変わっても動作するようにできる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Template Method&lt;/h2&gt;
&lt;p&gt;抽象クラスを用いて必要なメソッドと、その利用方法のロジックを先に定義する手法。
抽象クラスにはサブクラスに実装を任せるための抽象メソッドと、抽象クラスから提供するfinalメソッドがある。
サブクラスは抽象メソッド実装し、clientコードは抽象クラスを型としたサブクラスをインスタンス化することで、
同様のfinalメソッドから異なるロジックを引き出すことができる。
このパターンの最も大きな恩恵はfinalメソッドを抽象クラスで定義することで生まれる。
finalメソッド内のロジックはどのサブクラスをインスタンス化しても共通のため、
バグが生まれた箇所を見つけやく、もしfinalメソッドのロジックにバグがあったとしても一箇所中傷メソッドを書き換えればよい。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-4&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Factory Method&lt;/h2&gt;
&lt;p&gt;Template Methodパターンの応用である。
インスタンスの生成についてTemplate Methodパターンを用いることで、インスタンス生成時のロジックを一様化できる。
インスタンスの生成を担うクラスをFactory、生成されるインスタンスをProductと置くと&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;pacakge framework&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Product&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;package&lt;/span&gt; framework&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Factory&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Product&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; owner&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;Product&lt;/span&gt; p &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; create &lt;span class=&quot;token class-name&quot;&gt;Product&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;owner&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token function&quot;&gt;registerProduct&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;p&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; p&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Product&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createProduct&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; owner&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;registerProduct&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Product&lt;/span&gt; product&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上記のように記述することで、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;インスタンス生成のために &lt;code class=&quot;language-text&quot;&gt;create&lt;/code&gt; を用いること&lt;/li&gt;
&lt;li&gt;Stringを引数と取るコンストラクタをProductに記載すること&lt;/li&gt;
&lt;li&gt;Factoryのサブクラスは &lt;code class=&quot;language-text&quot;&gt;createProduct&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;registerProduct&lt;/code&gt; を実装すること&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;がわかる。
実際にこれらの抽象クラスを適用するサブクラスについてはpackageレベルで独立させることが可能となる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-5&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Singleton&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;指定したクラスのインスタンスが絶対に一つしか存在しないことを保証したい&lt;/li&gt;
&lt;li&gt;インスタンスが一つしか存在しないことをプログラム上で表現したい&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;時に使用されるパターンがSingletonパターンである。
コンストラクタをprivateにして、staticフィールドに自クラスのインスタンスを生成し、
そのインスタンスを返却するstatic publicな関数を定義することで実現できる。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Singleton&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Singleton&lt;/span&gt; singleton &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Singleton&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Singleton&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;インスタンスを生成しました。&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Singleton&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; singleton&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上記のFactory MethodパターンにおけるFactoryなどもこのようにSingletonとして記述されることが多い。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-6&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Prototype&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;種類が多すぎてクラスにまとめられない場合&lt;/li&gt;
&lt;li&gt;クラスからのインスタンス生成が難しい場合&lt;/li&gt;
&lt;li&gt;フレームワークと生成するインスタンスを分けたい場合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このような場合、クラス名を指定してインスタンスを生成することが困難となる。
インスタンスから別のインスタンスを生成するパターンをPrototypeパターンと呼び、上記のような課題を解決することができる。&lt;/p&gt;
&lt;p&gt;図形エディタアプリケーションを作成することを想定する。
三角や四角などオブジェクトをObjectインタフェースとして定義し、
個々のオブジェクトの詳細実装をTriangleObject, RectangleObjectなどとする。
また、それらのインスタンスを管理するクラスをManager、メインの処理系を記述するクラスをMainクラスとする。&lt;/p&gt;
&lt;p&gt;Objectインタフェースは &lt;code class=&quot;language-text&quot;&gt;java.lang.Cloneable&lt;/code&gt; インタフェースを継承する。
上記インタフェースを継承することで、インスタンスのコピー生成が可能になる。&lt;/p&gt;
&lt;p&gt;Managerクラスで個々のインスタンスを管理するが、ここでTriangleObjectについて色の情報を付与する必要があるとしよう。
Managerクラスで行えることはインスタンスのコピーと登録である。
Managerクラス内のmapにインスタンスの名称(String)とインスタンスを格納している。
さて、色情報についてだがTriangleObjectのコンストラクタに渡して色情報を付与することが自然であろう。
MainクラスでManagerクラスに機械的に色情報を付与したインスタンスを生成し格納していく。
事前に色情報を付与したインスタンスを生成しておくことで、コピーの下準備が完了する。&lt;/p&gt;
&lt;p&gt;マウスを用いた図形エディタを考えると、
図形の座標、スケール、回転角、アスペクト比などが必要になると考えられ、
それらのコピーをエディタ上でを行う際に
1からコンストラクタやセッターに図形の座標などの情報を引き渡すよりも
インスタンスを丸ごとクローンできた方が圧倒的に楽である。&lt;/p&gt;
&lt;p&gt;説明が紆余曲折した気がするが、これは私がこのパターンの利点を理解するまでに時間がかかったためである。
このパターンの主な利点はコピー可能性であり、
インスタンスを動的に作成する必要がある時に発揮されると考えている。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-7&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Builder&lt;/h2&gt;
&lt;p&gt;ビルを建てる時のように基盤から段階的に組み立てていき最終的なインスタンスを生成するパターンである。&lt;/p&gt;
&lt;p&gt;登場するクラスは4つであり、
メインプロセスを担当するClient, 実際に組み立てを行うDirector, 組み立ての手順を規定するBuilder,
手順に従って実質的な処理を記載したConcreteBuilderとなる。&lt;/p&gt;
&lt;p&gt;Builderは抽象クラスで必要となるすべての手順を先んじて記載しておく必要がある。
Directorは抽象クラスBUilderを用いて構築手順の通りメソッドを呼ぶ。
ConcreteBuilderは実際に使用されるクラスであり、Builderを継承した後に必要な処理を記載する。
以上を踏まえた上でClientのコードを下記に示す。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;ConcreteBuilder&lt;/span&gt; concreteBuilder &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ConcreteBuilder&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;Director&lt;/span&gt; director &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Director&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;concreteBuilder&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        director&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;construct&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; concreteBuilder&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getResult&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;result&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Builderパターンは交換可能性について大きなアドバンテージを得ることができる。
その反面、Builderクラスには必要十分なメソッド群をあらかじめ定義しておく必要があり、
設計の難易度が高いパターンや、修正の難しいパターンとも言える。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;私見: クラスメソッドのたびに自分のインスタンスを返すことでメソッドチェーンができるようになっているクラスを
よくBuilderクラスと呼んでいることが多い気がするのだが、それとは別のパターンのようである。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-8&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Abstract Factory&lt;/h2&gt;
&lt;p&gt;Factoryパターンが決められた手順で製品単体を生み出すパターンだとすれば、
Abstract Factoryパターンは複数の製品群を組み合わせるパターンである。&lt;/p&gt;
&lt;p&gt;メインプロセスを担当するClientの他に、Factoryの動作を定義するAbstractFactory抽象クラス、
製品のAPIを規定するAbstractProduct抽象クラス、
実際のFactory動作を記述したConcreteFactoryクラス、
実際の製品の挙動を記したConcreteProductクラスが必要なクラスとなる。
ここで、Productクラスについては複数ある方が自然である。&lt;/p&gt;
&lt;p&gt;Factoryクラスでは各Productのインスタンスを作成し返す関数を定義する。
また、依存関係を減らすためにAbstractFactoryクラスにはstatic関数として&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Factory&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Factory&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getFactory&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; classname&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;Factory&lt;/span&gt; factory &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            factory &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Factory&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;forName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;classname&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;newInstance&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ClassNotFoundException&lt;/span&gt; e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;err&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;クラス &quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; classname &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot; が見つかりません。&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Exception&lt;/span&gt; e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            e&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; factory&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ProductA&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createProductA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ProductB&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createProductB&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ProductA&lt;/span&gt; productA&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Amount&lt;/span&gt; amount&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ProductC&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createProductC&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;のようにクラス名をStringで渡してインスタンスを生成できるようにしておくとよい。&lt;/p&gt;
&lt;p&gt;これらを踏まえた上でMain関数は下記のようになる。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; factory&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;*&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;Factory&lt;/span&gt; factory &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Factory&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getFactory&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;args&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;token class-name&quot;&gt;ProductA&lt;/span&gt; productA1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; factory&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createProductA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;A1&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;ProductA&lt;/span&gt; productA2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; factory&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createProductA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;A2&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;token class-name&quot;&gt;ProductB&lt;/span&gt; productB1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; factory&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createProductB&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;productA1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;ProductB&lt;/span&gt; productB2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; factory&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createProductB&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;productA2&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;token class-name&quot;&gt;ProductC&lt;/span&gt; productC &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; factory&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createProductC&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        productC&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;productB1&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        productC&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;productB2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        productC&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Abstract Factoryパターンにおいて、ConcreteFactoryの種類を増やすことは容易である。
ただし、組み立てに必要な部品(製品)を増やすことは抽象クラスから書き換える必要があるため、面倒である。
それぞれのConcreteFactory, ConcreteProductの単位でパッケージングを行えばより再利用が容易なものができるが、
機械学習においてパイプラインを構築する際に使用する場合は、部品をすべて同一のパッケージに入れておき、
Factoryで各組み合わせを試していく実装を大量に用意するなどの書き方が良さそう。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-9&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Bridge&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;機能の追加&lt;/li&gt;
&lt;li&gt;機能の実装&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;のどちらかを行うために一般にサブクラスは実装される。
ただし、どちらも同様にスーバークラスから派生したサブクラスを作るだけのためこれらの意図は混在してしまう。
うまくこれらの階層を分離するためのパターンがBridgeパターンである。&lt;/p&gt;
&lt;p&gt;ここでは実装が必要な部分とクラスのAPIを分離して考え、
APIを定義したAbstraction抽象クラスを作成し、実質的な実装の必要な箇所をImplementor抽象クラスに委譲する。
このように実装が必要な箇所とAPIを定義する箇所に分離しておけば、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;機能の追加を行う場合はAbstractionクラスを継承してクラス作成&lt;/li&gt;
&lt;li&gt;機能の実装を行う場合はImplementorクラスを継承してクラス作成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;と言うようにサブクラスを作成する際の意図を明確にクラス図として示せるようになる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-10&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Strategy&lt;/h2&gt;
&lt;p&gt;ソースコードのうち、アルゴリズムの部分のみを抽出しモジュール化する考え方。
アルゴリズムに必要なAPIとシグネチャのみ先に定めてしまい、実際にそれを利用するクラスでは
アルゴリズムを委譲して使用する。
委譲によって複数のアルゴリズムを切り替えることが容易になっている。&lt;/p&gt;
&lt;p&gt;Abstract Factoryパターンなどとの主な差別化は着目しているものがアルゴリズムであることであろう。
これまではオブジェクト指向におけるオブジェクトの共有化等について考えてきたが、
アルゴリズムの分離については考えてこなかった。
アルゴリズムについてもオブジェクトと捉えることでプログラムの再利用性や疎結合性、テスト可能性が広がっていく。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-11&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Composite&lt;/h2&gt;
&lt;p&gt;端的に言うとマトリョーシカのようなパターンである。
代表的にファイルシシテムが挙げられ、「ディレクトリ」の中に「ディレクトリ」を入れることが可能である。
このような入子構造について表現する際に使えるのがCompositeパターンとなる。&lt;/p&gt;
&lt;p&gt;中身を表すLeafクラス、容器を表すCompositeクラス、LeafとCompositeを同一視するためのComponentクラスの3つを定義する必要がある。&lt;/p&gt;
&lt;p&gt;上記でほとんど説明が済んだようなものだが、容器と中身を同一視することで入子構造が容易に表現できるようになる。&lt;/p&gt;
&lt;p&gt;ファイルシステムを考えた場合、Componentの追加を行う関数をどこで実装するかはいくつかのパターンに分けられる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Componentクラスに実装しエラーを発生させる。Compositeクラスではoverrideを行う。&lt;/li&gt;
&lt;li&gt;Componentクラスに実装しエラーにしない。Leafクラスにも実装せずファイルの場合何も起こらない。&lt;/li&gt;
&lt;li&gt;Componentクラスで宣言し実装はCompositeクラス、Leafクラスで行う。&lt;/li&gt;
&lt;li&gt;Componentクラスには何も書かず、Compositeクラスにのみ定義する。使用する際はCompositeクラスへのキャストを毎回試みる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再起的な構造を表現する際に一考するとよい。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-12&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Decorator&lt;/h2&gt;
&lt;p&gt;あるクラスについて外側から何かを追加し、また追加されたものも含めて元のクラスと同一視するクラスである。&lt;/p&gt;
&lt;p&gt;Componentクラスは上記のCompositeパターンと同様、同一視する元となるクラスを表す。
ConcreteComponentクラスは最も大元となるComponentクラスの実装者である。
DecoratorクラスはComponentクラスと同様のAPIを持ち、Componentクラスをメンバーとして保持する。
ConcreteDecoratorクラスはDecoratorクラスの実装であり、メンバーであるComponentクラスのメソッドを用いて、
付加価値をつけながら同一APIを提供する。&lt;/p&gt;
&lt;p&gt;このように元のComponentクラスにいくつかの衣装を着せるように機能を追加していくことで、
中身を変えずに機能の追加が行えたり、動的な機能追加を実現することができる。&lt;/p&gt;
&lt;p&gt;ただし、問題点としてはよく似た小さいクラスが幾つも生まれてしまうと言うものがある。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-13&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Visitor&lt;/h2&gt;
&lt;p&gt;処理と構造を分離するためのパターンである。
Compositeパターンに代表されるように構造化されたクラス群を扱う際に、
そのクラスに直接処理を書き込むことはいたずらに修正箇所を増やすことにつながりかねない。
そのため、処理を構造から分離しVisitorという形で構造に沿って再帰的に呼び出させることで実装する。&lt;/p&gt;
&lt;p&gt;Visitorではvisitメソッドを構造における要素の種類分overloadして定義する。
ConcreteVisitorでは実際の処理を定義する。ここで、再帰的に処理を実現する必要があるが、
Iteratorパターンや、ダブルディスパッチをうまく利用して実現する。
ElementはVisitorの訪問先である。Visitorのためのダブルディスパッチ用関数として &lt;code class=&quot;language-text&quot;&gt;public void accept(visitor)&lt;/code&gt; を用意しておくとよい。
ObjectStructureは構造が定義されているクラスである。Elementのサブクラスとなることが多い。Iterator等、構造において次に繋がる処理を記述しておく必要がある。&lt;/p&gt;
&lt;p&gt;基本的にはVisitorクラスのvisitメソッドに構造データを渡せば、再帰的にvisitメソッドとacceptメソッドが相互依存して呼び出され、最終的なnode, leafにたどり着く。&lt;/p&gt;
&lt;p&gt;一般にConcreteVisitorを増やすことは容易だが、Elementの種類を増やすことは面倒である。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-14&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Chain of Responsibility&lt;/h2&gt;
&lt;p&gt;効率的にたらい回しを行うためのパターンである。&lt;/p&gt;
&lt;p&gt;処理者を規定するHandler抽象クラス、実装されたConcreteHandlerクラスが主なクラスである。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Handler&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Handler&lt;/span&gt; next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Handler&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;setNext&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Handler&lt;/span&gt; next&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Event&lt;/span&gt; event&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;event&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token function&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;event&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            next&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;event&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token function&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;event&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Event&lt;/span&gt; event&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Event&lt;/span&gt; event&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;event &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot; is resolved by &quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Event&lt;/span&gt; event&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;event &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot; cannot be resolved.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上記のようにsetNextメソッドなどで次のたらい回し先を決めておくことで、処理を順繰りに行っていく。
直接的なswitch-caseなどよりは処理が遅くなるが、処理内容や条件の独立性が担保される。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-15&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Facade&lt;/h2&gt;
&lt;p&gt;Facadeは「建物の正面」という意味を持った言葉であり、実質的に必要な処理に対してユースケースが限られ、
外部に提供するAPIを絞ることが可能なときにその処理の窓口としてFacadeクラスを提供することで、
Client目線でプログラムの可読性を上げるパターンである。&lt;/p&gt;
&lt;p&gt;複数クラスに処理がまたがっている場合でも、それらをまとめて行う決まった手順などがあり、
外部から必要な引数などが限られている場合は、全てをラッピングして新しいFacadeクラスを作ることで
単純な呼び出しによって処理を完遂することが可能になる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-16&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Mediator&lt;/h2&gt;
&lt;p&gt;多数のオブジェクトの間の調整を行わなければならない時に、Mediatorパターンは役に立つ。&lt;/p&gt;
&lt;p&gt;Mediatorインタフェースは調整の中心であり、
全てのColleagueクラスをメンバーとして保持していることを前提としたそれらの振る舞いについて規定するメソッドを定義している。
ConcreteMediatorクラスは実際に全てのColleagueクラスをメンバにもち処理について実装する。
Colleague抽象クラスはメンバーとしてMediatorインタフェースを所有し、自インスタンスの振る舞いについてのメソッドが定義され、
ConcreteColleagueクラスにより実装される。
この際、メソッドには他のインスタンスとの協調部分については書かず、あくまで自インスタンスの振る舞いの範疇で記述する。&lt;/p&gt;
&lt;p&gt;上記のようにすることで、複雑な複数のオブジェクトの協調処理を中央集中的に管理することができ、
複雑な処理のデバッグ箇所を大幅に減らすことができる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-17&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Observer&lt;/h2&gt;
&lt;p&gt;このパターンは状態の管理を監視するためのパターンである。&lt;/p&gt;
&lt;p&gt;主要なクラスは4つであり、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Subject&lt;/li&gt;
&lt;li&gt;ConcreteSubject&lt;/li&gt;
&lt;li&gt;Observer&lt;/li&gt;
&lt;li&gt;ConcreteObserver&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;となる。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Observer&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Subject&lt;/span&gt; subject&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;util&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;util&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Subject&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ArrayList&lt;/span&gt; observers &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;addObserver&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Observer&lt;/span&gt; observer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        observers&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;observer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;deleteObserver&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Observer&lt;/span&gt; observer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        observers&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;observer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;notifyObservers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;Iterator&lt;/span&gt; it &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; observers&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;it&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token class-name&quot;&gt;Observer&lt;/span&gt; o &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Observer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;it&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            o&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上記のようにSubjectは自分に必要な観察者を自身で保有し、
必要なタイミングで通知を飛ばすようにする。
Observerはupdateに記載された処理を行う。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-18&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Memento&lt;/h2&gt;
&lt;p&gt;状態の保存を行う時に考えられるパターンである。&lt;/p&gt;
&lt;p&gt;OrigiatorクラスがMementoクラスを作成することで、Origiatorクラスのある状態を保存する。
この時、Mementoクラスにアクセスできるのは基本的にOrigiatorクラスに制限され、
外部へのAPIとしてはnarrow interfaceのみを提供するようにする。
narrow interfaceではMementoクラスの状態を操作することはできず、
可能なことは公開データの取得程度にとどまる。
Origiatorクラスにその状態を保存しろと指示し、保存されたMementoクラスを管理するクラスとしてCaretakerクラスも定義するとよい。
こうすることで、Mementoクラスの管理、操作に関する処理をOrigiatorクラスから分離し、複雑になりがちな
Mementoクラスの保存条件や、保存期間などを独立して考えることができる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-19&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;State&lt;/h2&gt;
&lt;p&gt;状態をクラスとして保持するパターンである。
これまではオブジェクトや処理について着目していたが、今回は状態について着目する。&lt;/p&gt;
&lt;p&gt;このパターンに当然必要になるのがStateクラスである。ここでは状態に依存した振る舞いをするメソッドを定義する。
ConcreteStateクラスは実際の状態ごとに定義される。状態の数だけConcreteStateクラスが実装されることとなる。
Contextクラスは現在の状態を表すConcreteStateクラスを保持し、ダックタイピングを使用して必要なメソッドを引き出す。&lt;/p&gt;
&lt;p&gt;状態に依存した処理をダックタイピングで捌けることが最大のメリットである。&lt;/p&gt;
&lt;p&gt;このパターンにおいて、状態遷移を誰が管理するのかは非常に重要である。
ContextクラスからConcreteStateクラスの実態を分離する場合は状態遷移を行うのはConcreteStateクラス内が良い。
この場合は、状態遷移に変更を加える必要が出てきた際に変更範囲が各ConcreteStateクラスになるというデメリットを受容する。
逆にContextクラスにおいて全ての状態遷移を管理するという方法もあるが、この場合はConcreteStateクラスと密結合になる。
その他に状態遷移のテーブルを使用する方法や、独立したクラスをさらに用意する方法などが考えられる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-20&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Flyweight&lt;/h2&gt;
&lt;p&gt;flyweightはご想像の通り「フライ級」のことであり、メモリ量を節約するためのデザインパターンである。
メモリ量の削減をFlyweightパターンはインスタンスの共有によって実現する。&lt;/p&gt;
&lt;p&gt;Flyweightクラスは共有したいプログラムである。
基本的には複雑な状態を持たず、放っておけば何度も新規インスタンスが作成されるものが対象となる。
FlyweightFactoryクラスはFlyweightクラスのインスタンスを作成し、自身のインスタンスの中に保持する。
2回目以降、Flyweightクラスが必要になった際はすでに作成して保持してあるインスタンスを返却する。&lt;/p&gt;
&lt;p&gt;Flyweightクラスが複数箇所に共有して持たせるクラスとなるため、本当に共有して問題ないかを吟味する必要がある。
一行の改変で思いもよらない場所に影響を与える可能性がある。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-21&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Proxy&lt;/h2&gt;
&lt;p&gt;proxyは「代理人」を意味する英単語で、このパターンでは実際に処理を行うクラスの前段に代理のクラスを立てる。&lt;/p&gt;
&lt;p&gt;このパターンは単純でSubject抽象クラスあるいはインタフェースが対象の振る舞いを規定する。
その上で、ProxyクラスとRealSubjectクラスが実装され、ClientはProxyクラスを呼び出す。
例えば、Proxyクラスには重たい処理をおかずに軽い処理のみを記述し、思い処理が必要になった場合のみ、
RealSubjectクラスのインスタンスを作成し処理を委譲する。
この仕組みよって、可能な限り軽い動作で処理を行うことができる。
また、HTTPにおいて有名なキャッシュ機能をProxyクラスに持たせることも可能である。
頭の片隅においておく必要があることはRealSubjectクラスはProxyクラスに依存せず、
逆にProxyクラスはRealSubjectクラスに依存することである。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-22&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Command&lt;/h2&gt;
&lt;p&gt;オブジェクト、処理、状態のクラスを紹介したが、今回は命令のクラス化である。
CommandパターンはEventパターンと呼ばれることもあり、特にGUIの開発では「イベント」がよく登場する。&lt;/p&gt;
&lt;p&gt;Commandクラスは命令のインタフェースを定義し、これを実装するのがConcreteCommandクラスである。
Commandクラスの処理の対象となるクラスをReceiverクラスとし、Commandクラスの命令実行インタフェースを起動するのがInvokerクラスとなる。&lt;/p&gt;
&lt;p&gt;命令をクラス化することで履歴の保存が容易になる。
命令が持つ情報量には気を使う必要がある。不要な情報まで持たせることはよくない。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-23&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Interpreter&lt;/h2&gt;
&lt;p&gt;このパターンではプログラムが解決しようとしている問題を簡単な「ミニ言語」で表現する。
正規表現などがこれにあたる。
詳細がややこしすぎるので踏み込まないが、文字列に対して構文解析を行いややこしい処理を文字列で起こすことを可能にする。
あるいはパターン化された処理の簡潔な表現を生み出すことが目的である。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;まとめ&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;何を主眼に置くかが重要&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一番拡張したい場所に注目&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;種類の増えるクラス&lt;/li&gt;
&lt;li&gt;足していきたい機能群&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一番修正の多い箇所に注目&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;クラスのデータ構造&lt;/li&gt;
&lt;li&gt;メソッドを呼び出す手順&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一番複雑な箇所に注目&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズム&lt;/li&gt;
&lt;li&gt;データ構造&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;拡張したい場所はなるだけ疎結合に&lt;/li&gt;
&lt;li&gt;修正の多い箇所はなるだけ一箇所に&lt;/li&gt;
&lt;li&gt;一番複雑な箇所はなるだけ一箇所で独立させて&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[マイクロサービスアーキテクチャのざっくりまとめ]]></title><description><![CDATA[マイクロサービスアーキテクチャを読んだのでざっくりまとめる]]></description><link>https://dondakeshimo.github.io/tech-blog/blog/microservice-architecture</link><guid isPermaLink="false">https://dondakeshimo.github.ioblog/microservice-architectureマイクロサービスアーキテクチャのざっくりまとめ</guid><dc:creator><![CDATA[dondakeshimo]]></dc:creator><pubDate>Sat, 19 Dec 2020 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;目次 &lt;!-- exclude-toc --&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec1-0-0&quot;&gt;マイクロサービスアーキテクチャ&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-0-1&quot;&gt;マイクロサービスを用いる利点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-0-2&quot;&gt;マイクロサービスを用いるデメリット&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec2-0-0&quot;&gt;サービスのモデル化&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-1&quot;&gt;優れたサービス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-2&quot;&gt;境界&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-3&quot;&gt;共有データベースは絶対にダメ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-4&quot;&gt;オーケストレーションとコレオグラフィ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-5&quot;&gt;RESTとRPCのトレードオフ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-6&quot;&gt;非同期イベントベース連携&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-7&quot;&gt;クライアントライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-8&quot;&gt;バージョニング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-9&quot;&gt;ユーザインタフェース&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec3-0-0&quot;&gt;デプロイ&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-0-1&quot;&gt;CI/CD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-0-2&quot;&gt;成果物&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-0-3&quot;&gt;サービス構成&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec4-0-0&quot;&gt;テスト&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec4-0-1&quot;&gt;テストの種類&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec5-0-0&quot;&gt;監視&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec5-0-1&quot;&gt;サービスについてのアドバイス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec5-0-2&quot;&gt;システムについてのアドバイス&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec6-0-0&quot;&gt;セキュリティ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec7-0-0&quot;&gt;マイクロサービスにおける留意点&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec7-0-1&quot;&gt;指標&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec7-0-2&quot;&gt;システム障害への対処法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec7-0-3&quot;&gt;キャッシング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec7-0-4&quot;&gt;CAP定理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec7-0-5&quot;&gt;サービスレジストリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec7-0-6&quot;&gt;サービスの文書化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec8-0-0&quot;&gt;マイクロサービスの原則&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec8-0-1&quot;&gt;ビジネス概念に沿ったモデル化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec8-0-2&quot;&gt;自動化の文化の採用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec8-0-3&quot;&gt;内部実装詳細の隠蔽&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec8-0-4&quot;&gt;全ての分散化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec8-0-5&quot;&gt;独立したデプロイ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec8-0-6&quot;&gt;障害の分離&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec8-0-7&quot;&gt;高度な観測&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec1-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;マイクロサービスアーキテクチャ&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://www.amazon.co.jp/%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3-Sam-Newman/dp/4873117607&quot;&gt;マイクロサービスアーキテクチャ&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上記の書籍をもとに学んだことをまとめていく。
まずマイクロサービスについての定義だが、&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;マイクロサービスは、協調して動作する小規模で自律的なサービスです。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;とのことである。
かなり曖昧であるが、サービス群に対してどこからがマイクロなサービスのような具体的な線引くのは難しい。
本書で説明しているマイクロサービスの特徴としては&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一つの機能に専念していること&lt;/li&gt;
&lt;li&gt;独立したデプロイが可能なこと&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;の2点が担保されていることがマイクロサービスの条件となっているようである。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-0-1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;マイクロサービスを用いる利点&lt;/h3&gt;
&lt;h5&gt;技術異質性&lt;/h5&gt;
&lt;p&gt;モノリシックなサービスに対し、技術選択の自由度が格段に上がる。
railsを使用して全てを管理しているアプリケーションにおいてrubyとJS以外のプログラミング言語を導入するのは容易ではないが、
適切にマイクロサービスに分割し機械学習分野に定評のあるPythonを推測部分に用いたり、
課金周りの処理には信頼と安定のJavaを使用したりなどといった選択が可能になる。&lt;/p&gt;
&lt;h5&gt;回復性(Resilience)&lt;/h5&gt;
&lt;p&gt;システムのあるコンポーネントに障害が発生しても、その障害が連鎖しなければ、
問題を分離してシステムの残りの部分は機能し続けることができる。
モノリシックサービスでは一つの障害が全体に波及しやすい。&lt;/p&gt;
&lt;h5&gt;スケーリング&lt;/h5&gt;
&lt;p&gt;モノリシックサービスと違い、処理の重いサービスに集中的にリソースを割くということが可能になる。
そのため、一般的に柔軟なスケーリングが可能となりコストを制御することが容易になる。&lt;/p&gt;
&lt;h5&gt;デプロイの容易性&lt;/h5&gt;
&lt;p&gt;大きなモノリシックサービスの軽微な変更に対してデプロイを行おうとすると、
変更量と釣り合わない長いビルド時間やリリース時間と戦う羽目になる。
また、リリースの失敗やバグ、障害の発生があると一気に全体に影響が出るため高頻度のリリースに精神的な障壁が生まれる。
サービスを分割した場合上記の懸念事項が軽減される。&lt;/p&gt;
&lt;h5&gt;組織面の一致&lt;/h5&gt;
&lt;p&gt;1チームはピザ2枚で足りる人数が良い。
そのような小規模チームで巨大なモノリシックサービスを見切るのは至難の技である。
一つのサービスと一つのチームを結びつけられるように分割することで、効率よくマネジメントが可能になる。&lt;/p&gt;
&lt;h5&gt;合成可能性&lt;/h5&gt;
&lt;p&gt;分割されたサービスを再利用することが容易になる。
例えば、シューズストアサービスが参照していたユーザサービスを
新たに開発するブックストアサービスも参照するようにするといったことが簡単にできる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec1-0-2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;マイクロサービスを用いるデメリット&lt;/h3&gt;
&lt;p&gt;明確に書籍には記述されていないがざっと思いつくものをまとめる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;結局コストパフォーマンスが悪くなることがありそう&lt;/li&gt;
&lt;li&gt;技術の自由度からチーム間の異動の際に学習コストが上がりそう&lt;/li&gt;
&lt;li&gt;インタフェースが増えるのでその分事故も起きやすそう&lt;/li&gt;
&lt;li&gt;理想のマイクロサービスの状態を全員が共有できていないとすぐにどこかで密結合が起こりそう&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;サービスのモデル化&lt;/h1&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;優れたサービス&lt;/h3&gt;
&lt;h5&gt;疎結合&lt;/h5&gt;
&lt;p&gt;あるサービスを変更しても別のサービスを変更する必要がない状態。&lt;/p&gt;
&lt;h5&gt;高凝集性&lt;/h5&gt;
&lt;p&gt;関連するビジネスロジックが一つのサービスに収まっている状態。
一つのロジックの振る舞いを変更したい時に、複数サービスにまたがって変更する必要がない状態。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;境界&lt;/h3&gt;
&lt;h5&gt;ビジネス的境界&lt;/h5&gt;
&lt;p&gt;大きなビジネスロジックを分解し、一つのビジネスロジックに着目した際外部との通信が必要な部分と必要のない部分に分割する。&lt;/p&gt;
&lt;h5&gt;技術的境界&lt;/h5&gt;
&lt;p&gt;分割の第一条件はビジネス境界であることを念頭に置く。技術的に分割できる部分は性能的な問題等を鑑みて分けても良い。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;共有データベースは絶対にダメ&lt;/h3&gt;
&lt;p&gt;疎結合性と凝集性の真逆をいくプラクティスであるのでいかなる代償を払っても避けるべきである。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-4&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;オーケストレーションとコレオグラフィ&lt;/h3&gt;
&lt;p&gt;通信モードにおいて、リクエスト/レスポンスとイベントベースの二つが存在する。
サービス間の関係性として
リクエスト/レスポンスを用いたオーケストレーションと
イベントベースの通信を用いたコレオグラフィがある。
一般に、コレオグラフィ手法に向かう傾向が強いシステムの方が疎結合で柔軟性がある。
リクエスト/レスポンスを使用する際にも非同期にするように心がければ、疎結合性がある程度担保できる。&lt;/p&gt;
&lt;h5&gt;オーケストレーション&lt;/h5&gt;
&lt;p&gt;オーケストラの指揮者のように中枢部のサービスに頼ってプロセスを推進する。
指揮者サービスが各マイクロサービスとリクエスト/レスポンスを行い、
データを集めて最終的なレスポンスを形成するというようなモデルがオーケストレーションである。
メリットとしてはモデルが非常に分かりやすいこと、問題の特定が容易なこと。
デメリットは、指揮者サービスが中央監督機関になりすぎること。
中央集約しすぎるとほとんどのロジックをその部分で行うことが効率的となり、
結果的にモノリシックなサービスが出来上がってしまう方向に引力が働く可能性がある。&lt;/p&gt;
&lt;h5&gt;コレオグラフィ&lt;/h5&gt;
&lt;p&gt;コレオグラフィはオーケストレーションとは違い中枢サービスがない。
代わりに入り口となっているサービスがイベントを発行し、
それらをサブスクライブしている各マイクロサービスがイベントをトリガーにプロセスを開始する。
一般的に問題特定やエラーハンドリングを行うことがオーケストレーションよりも難しくなる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-5&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;RESTとRPCのトレードオフ&lt;/h3&gt;
&lt;p&gt;リクエスト/レスポンス方式の通信の代表的なものとしてREST(REpresentational State Transfer)とRPC(Remote Process Call)がある。
これら二つのトレードオフについて考える。&lt;/p&gt;
&lt;h5&gt;REST&lt;/h5&gt;
&lt;p&gt;RESTの考え方とHTTPプロトコルは非常に相性が良いため、ここでは主にHTTPにおけるRESTについて考える。
HTTPリクエストを送ることによってリモートサーバに処理を依頼する。
ハイパーメディアコントロールにより、リソースにアクセスして次の操作を決定することが容易となり、サーバとクライアントの分離が進む。
欠点としては性能面や複雑さ、開発工数の増大などがある。&lt;/p&gt;
&lt;h5&gt;RPC&lt;/h5&gt;
&lt;p&gt;クライアントが単なる関数呼び出しを行うようにリモートサーバにリクエストを送れる手法である。
いくつかの問題として、クライアントサイドとサーバサイドの技術選択に制限がかかることや、
リモート呼び出しを抽象化しすぎた結果リモートサーバへのリクエストと気づかずに修正を入れてしまい事故につながるといったことがある。
最新のProtocol BuffersやThriftのような機構はこのようなデメリットを軽減している。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-6&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;非同期イベントベース連携&lt;/h3&gt;
&lt;p&gt;イベントベースの手法としてはメッセージキューを使用するものが代表的だろう。
HTTPを使用してAtomのような手法を使うことも可能である。
メッセージキューのインフラを整えるために追加の工数が大量に必要になるが、
完成した暁には大いなる疎結合性が得られる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-7&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;クライアントライブラリ&lt;/h3&gt;
&lt;p&gt;クライアントライブラリを使用する場合はクライアントサイドでアップグレードのタイミングを管理できるようにする。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-8&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;バージョニング&lt;/h3&gt;
&lt;p&gt;バージョニングが必要な場合はセマンティックバージョニングを使用するのが良い。
2.1.5のように &lt;code class=&quot;language-text&quot;&gt;MAJOR.MINOR.PATCH&lt;/code&gt; と数字に意味を持たせる。
これによりアップグレードした際に破壊的な変更が行われているかどうかを察知することが可能となる。&lt;/p&gt;
&lt;p&gt;その他の方式としては新旧のバージョンを共存させることが挙げられる。
どちらの方式も選べるような状態にし、旧バージョンを誰も参照しなくなった際に削除する。&lt;/p&gt;
&lt;p&gt;前者は頻繁なアップデートを行うインターフェースに、後者はそれほど頻繁でないものに使用することができると考えられる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-9&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;ユーザインタフェース&lt;/h3&gt;
&lt;p&gt;合成レイヤと考え、レイヤと接続する各サービスがそのレイヤに対して責任を持つのが好ましい。
BFF(Backends for Frontends)を使用することでサービス呼び出しの管理が容易になるが、
BFFの層で中間ロジックを入れると複雑さが増すので注意が必要。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;デプロイ&lt;/h1&gt;
&lt;p&gt;相互依存するマイクロサービスにおいてデプロイを適切に行うことは非常に重要である。
本章ではデプロイに関するテクニックや技術について言及する。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-0-1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;CI/CD&lt;/h3&gt;
&lt;h5&gt;継続的インテグレーション&lt;/h5&gt;
&lt;p&gt;CI(Continuous Integration)は、新たにチェックインされたコードが既存コードと適切に統合されるようにする。
実際にCIを行っているかどうかの質問として&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1日に一度はメインラインにチェックインしているか&lt;/li&gt;
&lt;li&gt;変更を検証するテストスイートがあるか&lt;/li&gt;
&lt;li&gt;ビルドが壊れた時に、素rを修正するのがチームの最優先事項か&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;というのがある。&lt;/p&gt;
&lt;h5&gt;CIとマイクロサービスのマッピング&lt;/h5&gt;
&lt;p&gt;CIを考える際に&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ソースコードリポジトリ&lt;/li&gt;
&lt;li&gt;CIビルドジョブ&lt;/li&gt;
&lt;li&gt;ビルド生成物&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;の3つについてマッピングを考える必要がある。
最終的な生成物が3つ出来上がると考えた時に、CIビルドジョブまで3つに分割するか、ソースコードリポジトリまで3つに分割するかで
3パターン考えることができます。
一般にCIビルドジョブを一気にやる手法は考えることが少ないことをメリットとして捉えられるかもしれないが無駄捉えられるかもしれないが
CIビルドジョブを分割し、ソースコードリポジトリを分割しない場合はリポジトリが一つなので、
チェックイン/チェックアウトのプロセスが容易になる。
しかし、独立すべき複数のサービスを同時にレビューする習慣がつくため、密結合なコードに気付きづらくなるという欠点は抱えている。
ソースコードリポジトリまで分割した場合、リポジトリの所有権がチーム単位で明確になり、独立したレビューを行うことができるが、
リポジトリをまたがる変更が難しくなるというデメリットがある。&lt;/p&gt;
&lt;h5&gt;継続的デリバリ&lt;/h5&gt;
&lt;p&gt;継続的デリバリ(CD: COntinuous Delivery)とはチェックインするたびに本番環境への準備状況に関する
フィードバックを常に得られ、さらに各チェックインを全てリリース候補として扱う手法である。
準備状況についてはビルドパイプラインによってステップに分けられて実行され、その成否において状況が判断できる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-0-2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;成果物&lt;/h3&gt;
&lt;p&gt;リリースまで考えた際にソースコードの成果物として出力されるものの種類とそれらの特徴について考える。&lt;/p&gt;
&lt;h5&gt;プラットフォーム固有の成果物&lt;/h5&gt;
&lt;p&gt;Javaの場合はjarファイルとwarファイル、Pythonの場合はEggのようなプログラミング言語に対する成果物が生成される。
しかし、それを稼働させるためにはそれぞれの成果物を実行するための環境を整える必要がある。
環境を整えるためにはchefのような自動構成管理ツールが役に立つ。&lt;/p&gt;
&lt;h5&gt;OS成果物&lt;/h5&gt;
&lt;p&gt;Red HatにおけるRPMやUbuntuにおけるdebのようなOS固有の成果物を生成する手法もある。
この場合、プラットフォーム固有の環境構築に依存する必要がなくなる。
しかし、OS固有の成果物の生成は一般に難易度が高いことや複数のOSにデプロイする場合には逆に手間がかかる可能性があるなどの欠点もある。&lt;/p&gt;
&lt;h5&gt;カスタムイメージの成果物&lt;/h5&gt;
&lt;p&gt;Puppet, Chef, Ansibleといった自動構成管理ツールの欠点は構成処理に時間がかかることである。
そのため、予め仮想マシンイメージを生成物とすることで各サーバへのデプロイ時間を軽減することができる。
また、イミュータブルサーバの概念を実現するのにも役に立つ。
この概念は端的にいうと、稼働中のサーバ郡は常に同じ状態にさせるために各々に対する変更は行わないようにするといったものである。
イメージを作成することで、SSH接続を不可にしてサーバを稼働させることが可能になり、概念としてのイミュータブルサーバを
より現実的なものとすることができる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3-0-3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;サービス構成&lt;/h3&gt;
&lt;p&gt;ホストとサービスをどのようにマッピングするかを考える。&lt;/p&gt;
&lt;h5&gt;1ホストに複数のサービス&lt;/h5&gt;
&lt;p&gt;スケールが難しい。
管理するホストが一つなのが楽。&lt;/p&gt;
&lt;h5&gt;ホストごとに一つのサービス&lt;/h5&gt;
&lt;p&gt;スケールアウトが容易。管理するホストが複数になるので監視等のコストがかかる。&lt;/p&gt;
&lt;h5&gt;物理と仮想化&lt;/h5&gt;
&lt;p&gt;仮想化に対するキーワードを記載する。
最新の仮想化ではオーバーヘッドがかなり軽減され、進めるにつれて柔軟性や再現性が上がるという恩恵を得られる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker&lt;/li&gt;
&lt;li&gt;Linuxコンテナ&lt;/li&gt;
&lt;li&gt;Vagrand&lt;/li&gt;
&lt;li&gt;ハイパーバイザ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec4-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;テスト&lt;/h1&gt;
&lt;p&gt;&lt;a id=&quot;sec4-0-1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;テストの種類&lt;/h3&gt;
&lt;h5&gt;Maricの4象限&lt;/h5&gt;
&lt;p&gt;Marickの4象限の派生系というものがある。
図を書くのが面倒なので、言葉で記載すが、4象限なので軸が二つあり、それぞれ &lt;code class=&quot;language-text&quot;&gt;ビジネス &amp;lt;-&amp;gt; 技術&lt;/code&gt; , &lt;code class=&quot;language-text&quot;&gt;プログラミングのサポートの大小&lt;/code&gt; である。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ビジネス、プログラミングのサポート小: 探索的テスト&lt;/li&gt;
&lt;li&gt;ビジネス、プログラミングのサポート大: 受け入れテスト&lt;/li&gt;
&lt;li&gt;技術、プログラミングのサポート小    : 性質テスト&lt;/li&gt;
&lt;li&gt;技術、プログラミングのサポート大    : 単体テスト&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;テストのスコープ&lt;/h5&gt;
&lt;p&gt;テストのスコープについては単体テストが最も狭く、End to Endテストが最も広い。
テストのスコープが大きくなるにつれてコードに対する自信が向上する。
テストのスコープが小さくなるにつれて実行時間が短くなり、分離性が向上する。&lt;/p&gt;
&lt;h5&gt;単体テスト&lt;/h5&gt;
&lt;p&gt;機能が適切かどうかに関して高速なフィードバックを得られることが単体テストの目的である。
コードのリファクタリングを支援するために非常に重要になる。&lt;/p&gt;
&lt;h5&gt;サービステスト&lt;/h5&gt;
&lt;p&gt;1マイクロサービスのみを対象としたテスト。
可動部がマイクロサービス単体に限定されているためテストの脆弱性が小さくなる。&lt;/p&gt;
&lt;h5&gt;End to Endテスト&lt;/h5&gt;
&lt;p&gt;サービス全体を対象としたテスト。
テストの脆弱性は大きくなり問題箇所の特定も難しくなるが、成功した際に最も大きな自信が得られる。
その他にテストの責任者が曖昧になりやすいという組織上の欠点があったり、実行時間が大きくなりやすかったりとくつかの問題点を抱えている。&lt;/p&gt;
&lt;h5&gt;コンシューマ駆動テスト&lt;/h5&gt;
&lt;p&gt;コンシューマ/クライアントがプロデューサ/サーバの試験を行う。
これにより確実にインタフェースの整合性が担保でき、End to Endテストよりも遥かに高速に試験が行える。
コンシューマ駆動テストを助けるツールとしてPactというものがある。&lt;/p&gt;
&lt;h5&gt;スモークテスト&lt;/h5&gt;
&lt;p&gt;新たにデプロイしたソフトウェアに対して実行し、そのデプロイが正常に機能していることを確認する。
これを行うためにデプロイとリリースを分離する必要がある。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ブルーグリーンデプロイメント&lt;/strong&gt;&lt;br&gt;
必要なサーバの倍量を準備しておき、半分に分割、片方にのみリクエストが流れる状態にする。
リクエストが来ていない側のサーバに新しいバージョンを行い、スモークテストを実施する。
スモークテストが成功したら、新しいバージョンにリクエストを流す。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;カナリアリリース&lt;/strong&gt;&lt;br&gt;
本番環境の一部に新しいバージョンをリリースする。
様々な観点から新しいバージョンに問題ないことを確認し、新しいバージョンの割合を最終的に100%にする。&lt;/p&gt;
&lt;h5&gt;機能横断テスト&lt;/h5&gt;
&lt;p&gt;非機能要件と呼ばれる通常の機能のように実装できないシステムの特性を表す用語があるが、その用語と同様のものとして機能横断要件というものを定義する。
多くの機能横断要件は本番環境のみでしか検証することができず、4象限で大別すると性質テストに当てはまる。
これらに関しては極力自動化できるようにするが不可能な部分は手動になり、臨機応変な対応が求められる。
多くの場合機能横断要件に関して検討されるのが遅いので、早めに考えるよう提案されている。&lt;/p&gt;
&lt;h5&gt;性能テスト&lt;/h5&gt;
&lt;p&gt;上記の機能横断要件の一部性能面を満たしているか確認するテストである。
性能テスト環境は本番環境と近しいものを用意する必要があり、努力が必要な場合が多いがボトルネックの特定など有意義な結果が得られる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec5-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;監視&lt;/h1&gt;
&lt;p&gt;&lt;a id=&quot;sec5-0-1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;サービスについてのアドバイス&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;最低でもインバウンド応答時間を追跡する。続いてエラー率、アプリケーションレベルのメトリクス。&lt;/li&gt;
&lt;li&gt;全ての下流のレスポンスの健全性を追跡する。最低でも下流呼び出しの応答時間を追跡し、可能ならエラー率も追跡する。&lt;/li&gt;
&lt;li&gt;メトリクスを収集する方法と場所を標準化する。&lt;/li&gt;
&lt;li&gt;可能なら標準的な場所に標準形式でログを記録する。&lt;/li&gt;
&lt;li&gt;基板となるOSを監視し、不正なプロセスを探し出して、キャパシティプランニングを実行できるようにする。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec5-0-2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;システムについてのアドバイス&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CPU使用率のようなホストレベルメトリクスはアプリケーションレベルのメトリクスと一緒に集約する。&lt;/li&gt;
&lt;li&gt;メトリクス格納ツールを使用し、システムレベルまたはサービスレベルで集約、掘り下げができるようにする。&lt;/li&gt;
&lt;li&gt;メトリクス格納ツールでシステムの傾向を把握するのに十分な期間のデータを保持できるようにする。&lt;/li&gt;
&lt;li&gt;ログの集約と格納用にクエリ可能なツールを一つは導入する。&lt;/li&gt;
&lt;li&gt;相関IDの標準化を検討する。&lt;/li&gt;
&lt;li&gt;対応が必要な条件を理解し、アラートやダッシュボードを作成する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec6-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;セキュリティ&lt;/h1&gt;
&lt;p&gt;マイクロサービスを利用するとモノリシックサービスと比較して強固なセキュリティを築ける可能性が得られ、
セキュリティの手法に関する自由度も上がる。
SAMLやSSOなどの統合的な認証方法についてはさらに学ぶ必要があるが、その他は基本的なセキュリティ法則を遵守する。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec7-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;マイクロサービスにおける留意点&lt;/h1&gt;
&lt;p&gt;&lt;a id=&quot;sec7-0-1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;指標&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;応答時間/遅延&lt;/li&gt;
&lt;li&gt;可溶性&lt;/li&gt;
&lt;li&gt;データの耐久性/損失性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec7-0-2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;システム障害への対処法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;タイムアウト&lt;/li&gt;
&lt;li&gt;サーキットブレーカー&lt;/li&gt;
&lt;li&gt;隔壁&lt;/li&gt;
&lt;li&gt;分離&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec7-0-3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;キャッシング&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;クライアント側、プロキシ、サーバ側のキャッシング&lt;/li&gt;
&lt;li&gt;HTTPでのキャッシング&lt;/li&gt;
&lt;li&gt;書き込みのキャッシング&lt;/li&gt;
&lt;li&gt;回復性のためのキャッシング&lt;/li&gt;
&lt;li&gt;オリジンサーバの隠蔽&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec7-0-4&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;CAP定理&lt;/h3&gt;
&lt;p&gt;整合性(Consistency)、可用性(availability)、分断耐性(partition tolerance)の中で、
故障モードでは二つを得る。三つ全てを保証することはできない。
分断耐性を犠牲にすることはできないため、APシステムかCPシステムかで故障モードを考える必要がある。
ただし、どちらか一方に振り切る必要はない。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec7-0-5&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;サービスレジストリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DNS&lt;/li&gt;
&lt;li&gt;ZooKeeper&lt;/li&gt;
&lt;li&gt;Consul&lt;/li&gt;
&lt;li&gt;Eureka&lt;/li&gt;
&lt;li&gt;自作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec7-0-6&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;サービスの文書化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Swagger&lt;/li&gt;
&lt;li&gt;HALとHALブラウザ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec8-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;マイクロサービスの原則&lt;/h1&gt;
&lt;p&gt;&lt;a id=&quot;sec8-0-1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;ビジネス概念に沿ったモデル化&lt;/h3&gt;
&lt;p&gt;ビジネスで境界づけられたコンテキストを技術概念に基づいたインタフェースよりも優先する。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec8-0-2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;自動化の文化の採用&lt;/h3&gt;
&lt;p&gt;管理するものが多く、複雑なマイクロサービスにおいて、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自動テストは必須&lt;/li&gt;
&lt;li&gt;CI/CDは必須&lt;/li&gt;
&lt;li&gt;カスタムイメージ/環境定義/イミュータブルサーバは推奨&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec8-0-3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;内部実装詳細の隠蔽&lt;/h3&gt;
&lt;p&gt;境界づけられたコンテキストをモデル化し、共有すべきモデルと隠すべきモデルを調べる。
サービスはデータベースを隠蔽し、データポンプや、イベントデータポンプを用いて
レポートのために複数のサービスからのデータを集約する。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec8-0-4&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;全ての分散化&lt;/h3&gt;
&lt;p&gt;チームにサービスを所有させる。
オーケストレーションではなくコレオグラフィとダムミドルウェアを選び、高度なエンドポイントを持たせる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec8-0-5&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;独立したデプロイ&lt;/h3&gt;
&lt;p&gt;破壊的な変更が必要な時でもバージョン付けされたエンドポイントを共存させてコンシューマに対して後方互換性を持たせるべきである。
ホストごとに一つのサービスを持つようにするとブルーグリーンやカナリアといったリリーステクニックを使用できる。
コンシューマ駆動契約を用いて、破壊的変更が起こる前にそれについて察知する。
コンシューマが自ら更新のタイミングを決められるようにする。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec8-0-6&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;障害の分離&lt;/h3&gt;
&lt;p&gt;リモート呼び出しをローカル呼び出しのように扱ってはいけない。
障害がどこでも起こりうることを念頭に対処法を施す。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec8-0-7&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;高度な観測&lt;/h3&gt;
&lt;p&gt;セマンティック監視を利用して、ログと統計データは集約する。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[cronジョブを追加する4つの方法]]></title><description><![CDATA[cronジョブの追加方法について調べたのでまとめる]]></description><link>https://dondakeshimo.github.io/tech-blog/blog/how-to-use-cron</link><guid isPermaLink="false">https://dondakeshimo.github.ioblog/how-to-use-croncronジョブを追加する4つの方法</guid><dc:creator><![CDATA[dondakeshimo]]></dc:creator><pubDate>Sat, 12 Dec 2020 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;目次 &lt;!-- exclude toc --&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec1-0-0&quot;&gt;モチベーション&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec2-0-0&quot;&gt;cronジョブを追加する4つの方法&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-1&quot;&gt;4つの方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-2&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;crontab -e&lt;/code&gt; によるエディタを用いた編集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-3&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;crontab [file]&lt;/code&gt; によるファイルの読み込み&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-4&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;/etc/crond.d/&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec2-0-5&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;/var/spool/cron/crontabs/$USER&lt;/code&gt; にファイルを追加&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec3-0-0&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec1-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;モチベーション&lt;/h1&gt;
&lt;p&gt;現在作成しているCLIアプリケーションについてcronジョブを設定する必要があった。
cronジョブの設定方法としては &lt;code class=&quot;language-text&quot;&gt;crontab -e&lt;/code&gt; を用いる方法を知っていたが、プログラム内から
ジョブを編集するにはエディタを開かれては困るということでその他の方法を調べたのでついでにここにまとめる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;cronジョブを追加する4つの方法&lt;/h1&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;4つの方法&lt;/h3&gt;
&lt;p&gt;先に調べた方法をそれぞれ記載する&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;crontab -e&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;crontab [file]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;/etc/cron.d/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;/var/spool/cron/crontabs/$USER/&lt;/code&gt; ？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最後の方法は動作未検証のため？をつけている。
それぞれの特徴を以下に述べていく。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;crontab -e&lt;/code&gt; によるエディタを用いた編集&lt;/h3&gt;
&lt;p&gt;言わずと知れたエディタで編集する方法。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;console&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ crontab -u $USER -e&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;とすることで &lt;code class=&quot;language-text&quot;&gt;$USER&lt;/code&gt; 権限のcronジョブを作成することができる。
有名なデメリットに&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;console&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ crontab -r&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;を誤って起動してしまうというものがある。
こちらのコマンドはcronジョブを全消去するというもので非常に危険であるのに対し、
確認もなく、よく使うオプションの &lt;code class=&quot;language-text&quot;&gt;e&lt;/code&gt; の隣にある &lt;code class=&quot;language-text&quot;&gt;r&lt;/code&gt; であることから事故が立たないとのこと。
そのため、 &lt;code class=&quot;language-text&quot;&gt;/etc/crontab&lt;/code&gt; を直接編集する派閥もいるらしい。
上記の直接編集もこちらの項目に含めて考える。&lt;/p&gt;
&lt;h5&gt;pros&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;エディタでそのまま手軽に編集できる&lt;/li&gt;
&lt;li&gt;権限を決められる&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;cons&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;プログラムから使用しづらい&lt;/li&gt;
&lt;li&gt;死の危険と隣り合わせ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;crontab [file]&lt;/code&gt; によるファイルの読み込み&lt;/h3&gt;
&lt;p&gt;crontabコマンドは引数としてファイルを渡すとそのファイルを$USERのcronジョブ置き場に配置してくれる。
&lt;code class=&quot;language-text&quot;&gt;crontab -e&lt;/code&gt; と同様にユーザを指定することも可能。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;console&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ crontab -u $USER [file]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;pros&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;プログラムで使いやすい&lt;/li&gt;
&lt;li&gt;権限を決められる&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;cons&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;一度情報をファイルに起こさないといけない&lt;/li&gt;
&lt;li&gt;削除や編集の仕方がわからない？ &amp;#x3C;- 要検証&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-4&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;/etc/crond.d/&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;指定のディレクトリにジョブを記載したファイルを配置する。
cronは &lt;code class=&quot;language-text&quot;&gt;/etc/cron.d/&lt;/code&gt; を含め、いくつかのディレクトリ配下に配置されたジョブファイルを自動で読み取りに行く。
ファイルを配置しておくだけなのでかなり自由度高くジョブを操作できる。
問題点は権限がrootでなくてはいけないところ。&lt;/p&gt;
&lt;h5&gt;pros&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;ファイルを配置するだけなので自由度高い&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;cons&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;権限がrootのみ&lt;/li&gt;
&lt;li&gt;file modeにも気を使う必要がある (確か644のみ)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec2-0-5&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;/var/spool/cron/crontabs/$USER&lt;/code&gt; にファイルを追加&lt;/h3&gt;
&lt;p&gt;上記の &lt;code class=&quot;language-text&quot;&gt;/etc/cron.d/&lt;/code&gt; 配下にファイルを追加する方法だと権限がrootになってしまうということで調べた方法。
&lt;code class=&quot;language-text&quot;&gt;/var/spool/cron/crontabs/$USER&lt;/code&gt; は &lt;code class=&quot;language-text&quot;&gt;crontab -u $USER&lt;/code&gt; としたときに開かれるcronジョブファイルが配置されている場所なので
権限は &lt;code class=&quot;language-text&quot;&gt;$USER&lt;/code&gt; になるはずである。
ただし落とし穴があり、 &lt;code class=&quot;language-text&quot;&gt;/var/spool/cron/crontabs/&lt;/code&gt; には &lt;code class=&quot;language-text&quot;&gt;$USER&lt;/code&gt; に対して書き込み権限どころか読み取り権限すら
与えられておらず現実的に目的の位置にファイルを配置するためにはroot権限が必要なることである。
調べている途中で使うことはないなと思ったので本当に動くかどうかも怪しいのは許していただきた。&lt;/p&gt;
&lt;h5&gt;pros&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;ファイルを配置するだけなので自由度高い&lt;/li&gt;
&lt;li&gt;$USER権限&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;cons&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;配置するためにroot権限が必要&lt;/li&gt;
&lt;li&gt;file modeに気を使う必要がある&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec3-0-0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;まとめ&lt;/h1&gt;
&lt;p&gt;以上、まとめてみた感想だが、cronは意外と扱いづらいことがわかった。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[modern C++erの流儀]]></title><description><![CDATA[C++11以降大きく変わったC++をどの様に扱うべきかを記したEffective Modern C++を読んだのでまとめる]]></description><link>https://dondakeshimo.github.io/tech-blog/blog/effective-modern-cpp</link><guid isPermaLink="false">https://dondakeshimo.github.ioblog/effective-modern-cppmodern C++erの流儀</guid><dc:creator><![CDATA[dondakeshimo]]></dc:creator><pubDate>Mon, 23 Nov 2020 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;モチベーション&lt;/h1&gt;
&lt;p&gt;私は業務でC++を使用している。
聞いて驚いてほしいことに最近までのC++のコンパイラはC++98までしか理解しないものだった。
過去形ということでお気づきだと思うが、つい最近、
と言っても数ヶ月前だがコンパイラを新しいものに変えC++11をコンパイルする準備ができた。
私はまだC++を使い始めて1年経っておらず、C++98の範囲でさえ分かっているとは言い難い状況だが、
嫌だからこそ、この機にモダンなC++の書き方というものを学びたく思い
&lt;a href=&quot;https://www.oreilly.co.jp/books/9784873117362/&quot;&gt;Effective Modern C++&lt;/a&gt; を購入した。
やや嘘をついた、上述の本を購入したのは実はC++を学び始めてすぐで1年ほど前である。
C++初学者であった私にこの書籍はあまりに難しく当時は挫折した。
1年の修行期間を経てリベンジした結果なんとか完走することができたので、
実際に自分が使いそうなものや覚えておいた方が良さそうなことをここにまとめる。&lt;/p&gt;
&lt;h1&gt;Effective Modern C++&lt;/h1&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec1&quot;&gt;型推論にまつわる流儀&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec11&quot;&gt;テンプレートとauto&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec12&quot;&gt;decltype&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec2&quot;&gt;ポインタにまつわる流儀&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec21&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec22&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec23&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec24&quot;&gt;newの可能な範囲での撲滅&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec4&quot;&gt;moveにまつわる流儀&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec41&quot;&gt;std::move, std::forward&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec42&quot;&gt;ユニヴァーサル参照, 右辺値参照&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec43&quot;&gt;右辺値参照ならstd::move, ユニヴァーサル参照ならstd::forward&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec44&quot;&gt;ユニヴァーサル参照をとるオーバーロードの撲滅&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#sec3&quot;&gt;モダンC++の流儀&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec31&quot;&gt;初期化子の統一&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec32&quot;&gt;nullptr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec33&quot;&gt;エイリアス宣言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec34&quot;&gt;scoped enum&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec35&quot;&gt;未定義private関数の撲滅&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec36&quot;&gt;overrideの宣言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec37&quot;&gt;const_iterator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec38&quot;&gt;noexcept, constexpr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec39&quot;&gt;要素の挿入, 直接配置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;型推論にまつわる流儀&lt;/h2&gt;
&lt;p&gt;&lt;a id=&quot;sec11&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;テンプレートとauto&lt;/h4&gt;
&lt;p&gt;型推論を行う代表的な場面がテンプレートを使用した場合とautoを宣言した場合となる。
テンプレートとautoの型推論は基本的に同じものであるため、
まずはテンプレートを例にとってどの様な型推論が行われるか理解する。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;cpp&quot;&gt;&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typename&lt;/span&gt; T&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ParamType param&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;expr&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;この場合 &lt;em&gt;T&lt;/em&gt; の推論には呼び出しの型だけではなく &lt;em&gt;ParamType&lt;/em&gt; の型にも左右される。
具体的には以下の様に場合分けできる&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;ParamType&lt;/em&gt; が参照もしくはポインタだがユニヴァーサル参照ではない&lt;/li&gt;
&lt;li&gt;&lt;em&gt;ParamType&lt;/em&gt; がユニヴァーサル参照である&lt;/li&gt;
&lt;li&gt;&lt;em&gt;ParamType&lt;/em&gt; がポインタでも参照でもない&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;&lt;em&gt;ParamType&lt;/em&gt;が参照もしくはポインタだがユニヴァーサル参照ではない&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;expr&lt;/em&gt; が参照型ならば、参照性を無視する&lt;/li&gt;
&lt;li&gt;&lt;em&gt;expr&lt;/em&gt; の型を &lt;em&gt;ParamType&lt;/em&gt; とパターンマッチングし、 &lt;strong&gt;T&lt;/strong&gt; を決定する&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;&lt;em&gt;ParamType&lt;/em&gt; がユニヴァーサル参照である&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;expr&lt;/em&gt; が左辺値ならば、 &lt;strong&gt;T&lt;/strong&gt; も &lt;em&gt;ParamType&lt;/em&gt; も左辺値参照と推論される&lt;/li&gt;
&lt;li&gt;&lt;em&gt;expr&lt;/em&gt; が右辺値ならば、先述の規則が適用される&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;&lt;em&gt;ParamType&lt;/em&gt; がポインタでも参照でもない&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;expr&lt;/em&gt; の型が参照ならば、参照性を無視する&lt;/li&gt;
&lt;li&gt;参照性を無視した &lt;em&gt;expr&lt;/em&gt; の型が &lt;strong&gt;const&lt;/strong&gt; , &lt;strong&gt;volatile&lt;/strong&gt; であればこれを無視する&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;ポインタへの成り下がり&lt;/h5&gt;
&lt;p&gt;配列または関数実引数はテンプレートの型推論時にポインタに成り下がる&lt;/p&gt;
&lt;h5&gt;autoとテンプレート推論の差異&lt;/h5&gt;
&lt;p&gt;autoとテンプレートの型推論はほとんど同一のアルゴリズムで解決される。
ただ一つの違いはautoが波括弧で囲んだ初期化子をstd::initilizer_listと &lt;em&gt;想定する&lt;/em&gt; のに対し、
テンプレートの型推論は想定しないと言う点だ。&lt;/p&gt;
&lt;h5&gt;明示的型宣言よりもautoを優先する&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;autoで宣言した変数は初期化する必要があり未定義動作を防げる&lt;/li&gt;
&lt;li&gt;一般に可搬性や効率に関する問題を引き起こす型の不一致を防げる&lt;/li&gt;
&lt;li&gt;型の暗黙的変換が行われないため意図的に変更させる必要があり可読性が上がる(明示的片付け初期化子の使用)&lt;/li&gt;
&lt;li&gt;リファクタリングを容易にする&lt;/li&gt;
&lt;li&gt;タイプ量が減る&lt;/li&gt;
&lt;li&gt;プロクシ型はautoに誤った型を推論させるので注意する&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec12&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;decltype&lt;/h4&gt;
&lt;p&gt;decltype は変数を与えるとその型を返す関数である。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;cpp&quot;&gt;&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;vector&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; v&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;// decltype(v) is vector&amp;lt;int&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用用途として戻り型が仮引数の型により決定される関数テンプレートの宣言が挙げられる。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;cpp&quot;&gt;&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// c++11 version&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typename&lt;/span&gt; Container&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;typename&lt;/span&gt; Index&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;sampleContainerAccesser&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Container&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Index i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; c&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// c++14 version&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typename&lt;/span&gt; Container&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;typename&lt;/span&gt; Index&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;sampleContainerAccesser&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Container&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Index i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; c&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上記の記法は &lt;strong&gt;戻り型の後置&lt;/strong&gt; (trailing return type) と呼ばれているものである。
上記の例は改良の余地があり、一つは右辺値を受け付ける必要があること、
もう一つは返り値を必要なら右辺値にする方が効率が良いことだ。それらを反映させると&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;cpp&quot;&gt;&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// c++11 version&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typename&lt;/span&gt; Container&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;typename&lt;/span&gt; Index&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;sampleContainerAccesser&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Container&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Index i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;forward&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Container&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;forward&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Container&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// c++14 version&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typename&lt;/span&gt; Container&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;typename&lt;/span&gt; Index&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;sampleContainerAccesser&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Container&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Index i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;forward&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Container&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;std::forwardについては後続の説明に記載予定。&lt;/p&gt;
&lt;h5&gt;decltypeの注意点&lt;/h5&gt;
&lt;p&gt;変数を括弧で囲むと参照が付与されてしまうので注意。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;cpp&quot;&gt;&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;token comment&quot;&gt;// -&gt; int&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;// -&gt; int&amp;amp;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a id=&quot;sec2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;ポインタにまつわる流儀&lt;/h2&gt;
&lt;p&gt;&lt;a id=&quot;sec21&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;std::unique_ptr&lt;/h4&gt;
&lt;p&gt;独立するリソースの管理には std::unique_ptr を使用する。
std::unique_ptrはムーブ専用型であり、独占所有セマンティクスを所有する。&lt;/p&gt;
&lt;p&gt;std::unique_ptrのインターフェースは二つあり、カスタムデリータを引数にとるものと取らないものがある。
カスタムデリータにはラムダ式を使用した方が時間、空間計算量が優れる。
カスタムデリータを用いる際の注意点としてstd::unique_ptr 自体のメモリ使用量が増加することが挙げられる。&lt;/p&gt;
&lt;p&gt;std::unique_ptrの大きな魅力は独占所有権を有しながら、std::shared_ptrへの変換が簡単なことだ。
これはfactory関数の戻り型としてstd::unique_ptrが非常に優れている理由となる。
関数側からはポインタが共有されるべきか独占されるべきか判断できないため、
呼び出し側で好きに置き換えが可能なことで柔軟性を保持している。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec22&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;std::shared_ptr&lt;/h4&gt;
&lt;p&gt;共同所有権を必要とするリソースの管理にはstd::shared_ptrを利用する。
std::shared_ptrはreference countから地震がそのリソースを指す最後のポインタか否かを判断できる。
即ちstd::shared_ptrのコンストラクタはreference countをインクリメントし、
デストラクタはデクリメントする。&lt;/p&gt;
&lt;p&gt;reference countを保持することでrawポインタと比較して性能面に負債を背負うこととなる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;std::shared_ptrのサイズがrawポインタの2倍になる&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;reference countをダイナミックにメモリ割り当てする必要がある&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;std::make_sharedの利用により回避できる&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;reference countのincrement/decrementはアトミックに実行する必要がある&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;move演算をすることによってreference countを操作しなくて済む&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;std::shared_ptrもstd::unique_ptrと同様にカスタムデリータを指定できる。
これら二つのカスタムデリータを指定したスマートポインタは型にデリータを含むかどうかで差異が存在する。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;cpp&quot;&gt;&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// deleter type is part of ptr type&lt;/span&gt;
std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;unique_ptr&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Widget&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loggingDel&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;upw&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; Widget&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; loggingDel&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// deleter type is not part of ptr type&lt;/span&gt;
std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;unique_ptr&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Widget&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;spw&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; Widget&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; loggingDel&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これらはポインタの取り回しの柔軟性にも差異を与える。
例えばコンテナ型に上記のポインタを代入することを考えると、
std::unique_ptrは全て同一のカスタムデリータを指定しない限りコンテナにまとめることができないが、
std::shared_ptrは自由にカスタムデリータを指定できる。&lt;/p&gt;
&lt;p&gt;std::shared_ptrはreference countを含むコントロールブロックと呼ばれるデータを所有している。
コントロールブロック内にカスタムデリータのデータも含まれるため、
std::shared_ptrはstd::unique_ptrと違いカスタムデリータを指定してもサイズが大きくならない。&lt;/p&gt;
&lt;p&gt;コントロールブロックは対象オブジェクトを指すstd::shard_ptrを最初に作成した関数が設定する。
ただし、一般にstd::shared_ptrが既に存在しているかを知る方法はないため、下記のルールを適用する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;std::make_sharedは常にコントロールブロックを作成する&lt;/li&gt;
&lt;li&gt;所有権が一意なポインタからstd::shared_ptrを作成した場合は常にコントロールブロックを作成する&lt;/li&gt;
&lt;li&gt;rawポインタを与えstd::shared_ptrコンストラクタを呼び出した場合はコントロールブロックを作成する&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上記のルールからrawポインタをコンストラクタに複数か渡すことで
バグの温床と非効率なコードが生成されることとなる。
上述の理由からクラス設計において自身のポインタ &lt;strong&gt;this&lt;/strong&gt; を使用したいシーンがあるが、
その際にstd::shared_ptrのコンストラクタへthisを渡していないか注意する必要がある。
自身のポインタをstd::shared_ptrとして扱う必要がある場合は基底クラステンプレートとして
std::enbale_shared_from_thisクラスを利用し、thisの代わりにshard_from_this()を使用する。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec23&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;std::weak_ptr&lt;/h4&gt;
&lt;p&gt;std::shared_ptrのように振る舞いながらも、対象リソースの所有権を共有しない
スマートポインタが有用になる場面がある。
この種のスマートポインタは対象が破棄された場合を考え、ポインタが不正(dangle)になったことを追跡管理し、
問題に対応すル必要がある。
これらを賄うC++のスマートポインタがstd::weak_ptrとなる。&lt;/p&gt;
&lt;p&gt;std::weak_ptrは必ずstd::shared_ptrに付随して使用される。
std::weak_ptrのコンストラクタにstd::shared_ptrを作成した時点から両者は同じメモリ上の位置を指し示す。
ただし、std::weak_ptrは対象オブジェクトのreference countには影響を及ぼさない。&lt;/p&gt;
&lt;p&gt;不正ポインタとなったstd::weak_ptrを &lt;strong&gt;expireされた&lt;/strong&gt; と表現する。
スマートポインタが不正かどうかを判定するには &lt;code class=&quot;language-text&quot;&gt;wpw.expired()&lt;/code&gt; を呼び出せば良いが、
一般に不正判定する目的は対象オブジェクトに無事アクセスできるかを確認することであり、
不正判定からアクセスまでの一連の処理がアトミックに行われる必要がある。
これを実現するためにはstd::weak_ptrをstd::shared_ptrに変換してやれば良い。
&lt;code class=&quot;language-text&quot;&gt;wpw.lock()&lt;/code&gt; を用いて初期化する方法とstd::shared_ptrのコンストラクタに直接渡す方法がある。&lt;/p&gt;
&lt;p&gt;std::weak_ptrは不正になる可能性のあるstd::shared_ptrライクなポインタで使用し、
具体的な利用先としては下記のようなパターンが挙げられる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;キャッシュ&lt;/li&gt;
&lt;li&gt;observer リスト&lt;/li&gt;
&lt;li&gt;std::shared_ptrの循環防止&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec24&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;newの可能な範囲での撲滅&lt;/h4&gt;
&lt;p&gt;newを回避するためにstd::make_uniqueとstd::make_sharedを積極的に使用する。
ただし、std::make_uniqueについてはC++14以降に追加された関数のため、以下に実装例を記す。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;cpp&quot;&gt;&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typename&lt;/span&gt; T&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; Ts&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;unique_ptr&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;T&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;make_unique&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Ts&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; params&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;unique_ptr&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;T&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;forward&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Ts&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;params&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;std namespaceに上記関数を置いた場合、C++14にアップグレードした際に衝突するため注意。&lt;/p&gt;
&lt;p&gt;newの直接使用と比較してmake関数はソースコードの重複を避け、例外安全性を向上できる。
また、std::make_sharedおよびstd::allocate_sharedでは高速化つサイズの小さなコードを生成できる。&lt;/p&gt;
&lt;p&gt;make関数を使用できないシーンにはカスタムデリータを指定する場合と波括弧による初期化を目的とする場合の
二つがある。&lt;/p&gt;
&lt;p&gt;std::shared_ptrの場合ではmake関数が適切でない場面が増え、専用のメモリ管理を実装したクラスや、
メモリに特別な注意が必要なシステム、巨大オブジェクト、
対応するstd::shared_ptrとは異なるライフタイムを持つstd::weak_ptrなどが挙げられる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec4&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;moveにまつわる流儀&lt;/h2&gt;
&lt;p&gt;&lt;a id=&quot;sec41&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;std::move, std::forward&lt;/h4&gt;
&lt;p&gt;std::moveおよびstd::forwardはキャストを実行する関数にすぎず、関数内でムーブ演算は実行されない。&lt;/p&gt;
&lt;p&gt;std::moveは右辺値への無条件キャストを実行する。&lt;/p&gt;
&lt;p&gt;std::forwardは実引数が右辺値にバインドされている場合に限り、その実引数を右辺値へキャストする。&lt;/p&gt;
&lt;p&gt;std::moveもstd::forwardもプログラム実行時には何も実行しない。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec42&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;ユニヴァーサル参照, 右辺値参照&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;cpp&quot;&gt;&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Widget&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; param&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;          &lt;span class=&quot;token comment&quot;&gt;// rvalue reference&lt;/span&gt;

Widget&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; var1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Widget&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;token comment&quot;&gt;// rvalue reference&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; var2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; var1&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;              &lt;span class=&quot;token comment&quot;&gt;// universal reference&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typename&lt;/span&gt; T&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;vector&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;T&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; param&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;// rvalue reference&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typename&lt;/span&gt; T&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;T&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; param&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;               &lt;span class=&quot;token comment&quot;&gt;// universal reference&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上記のコードから察せられるように「T&amp;#x26;&amp;#x26;」には二つの意味がある。
一つは右辺値参照であり、もう一つは右辺値参照か左辺値参照のどちらか一方を表すことである。
後者は型推論を伴うTに対し右辺値参照の記法を用いた際に発動する構文であり、
参照の初期化を行う際の初期化子が右辺値なら右辺値参照を、
左辺値なら左辺値参照をを表す。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec43&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;右辺値参照ならstd::move, ユニヴァーサル参照ならstd::forward&lt;/h4&gt;
&lt;p&gt;std::moveは右辺値参照に対し、std::forwardは最後に使用するユニヴァーサル参照に対し、
それぞれ実行するべきである。
これは値戻しする関数から返す右辺値参照、ユニヴァーサル参照についても同様のことが言える。&lt;/p&gt;
&lt;p&gt;ただし、 &lt;strong&gt;戻り値の最適化(return value optimization, RVO)&lt;/strong&gt; が適用される関数ではその限りではない。
RVOとは値戻しの関数において下記条件を満たした際にコピーを省略する仕様のことである。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ローカルオブジェクトの型が関数の戻り値の型に一致している&lt;/li&gt;
&lt;li&gt;戻り値となるのがそのローカルオブジェクトである&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この場合、std::move等を返り値に適用してしまうとRVOが発動せず結果的に効率の悪いコードになってしまう。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec44&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;ユニヴァーサル参照をとるオーバーロードの撲滅&lt;/h4&gt;
&lt;p&gt;ユニヴァーサル参照をとるオーバーロードを加えると、予想以上に多くの場面で、
ほぼ常にユニヴァーサル参照をとるオーバーロードが呼び出される。
完全転送コンストラクタは特に問題になる。非constな左辺値をとるコピーコンストラクタよりも
一致度が高くなるのが通例であり、派生クラスからの基底クラスの
コピー/ムーブコンストラクタ呼び出しをのっとってしまうためである。&lt;/p&gt;
&lt;p&gt;ユニヴァーサル参照をとるオーバーロードの代替策としては&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;オーバーロードしない&lt;/li&gt;
&lt;li&gt;const T&amp;#x26;を渡す&lt;/li&gt;
&lt;li&gt;値を渡す&lt;/li&gt;
&lt;li&gt;タグディスパッチを用いる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;がある。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec45&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;参照の圧縮&lt;/h4&gt;
&lt;p&gt;参照の圧縮とは型推論などの過程で参照の参照をコンパイラが生成した際に、
単一の参照に変換する動作のことである。
&lt;em&gt;二つある参照のいずれかが左辺値参照であれば、圧縮結果は左辺値参照となる。二つとも右辺値参照の場合は、圧縮結果は右辺値参照となる。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;参照の圧縮が発生する場面は4つある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;テンプレートのインスタンス化&lt;/li&gt;
&lt;li&gt;autoの型生成&lt;/li&gt;
&lt;li&gt;typedefとエイリアス宣言の使用と作成&lt;/li&gt;
&lt;li&gt;decltype&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id=&quot;sec45&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;完全転送&lt;/h4&gt;
&lt;p&gt;完全転送とはある関数が仮引数を他の関数へ渡す挙動であり、単なる転送と異なり、
仮引数のオブジェクトの性質(オブジェクトの型、左辺値か右辺値かなど)も転送する。
使用例としては下記のようになる。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;cpp&quot;&gt;&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; Ts&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fwd&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Ts&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; params&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;forward&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Ts&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;params&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完全転送はほとんどの場合意図通りに動作するが、まれに完全でない部分が露見する。
条例の目的関数fと転送関数fwdでは、同じ実引数に対する両者の動作が異なると完全転送できない。&lt;/p&gt;
&lt;p&gt;完全転送できない場合は二つで、fwdの仮引数の方を推論できない、
または誤った方を推論した場合、完全転送がエラーになる。&lt;/p&gt;
&lt;p&gt;完全転送のエラー原因となる実引数には、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;波括弧による初期化子&lt;/li&gt;
&lt;li&gt;ヌルポインタとして用いた0やNULL&lt;/li&gt;
&lt;li&gt;宣言のみのconst staticな汎整数メンバ変数&lt;/li&gt;
&lt;li&gt;テンプレート名&lt;/li&gt;
&lt;li&gt;オーバーロード関数名&lt;/li&gt;
&lt;li&gt;ビットフィールド&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;などがある。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;モダンC++の流儀&lt;/h2&gt;
&lt;p&gt;&lt;a id=&quot;sec31&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;初期化子の統一&lt;/h4&gt;
&lt;p&gt;初期化の方法は大きく以下の三つの記法に分類される。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;cpp&quot;&gt;&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; y &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; z&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;多くの場合、等号と波括弧は併用できるが、波括弧のみの時と同じのため等号はこの項では無視する。&lt;/p&gt;
&lt;p&gt;C++11になり、初期化子の統一記法を導入したことで
波括弧による初期化が概ねどのような場面でも適用できるようになった。
そのため、これまで等号と丸括弧を場面場面で使い分けていたコピー不可能なオブジェクトの初期化や、
非スタティックなメンバ変数のdefault値の指定に加えて、等号と丸括弧では表現できなかった
コンテナの初期要素の指定も全て波括弧を用いて行えるようになった。&lt;/p&gt;
&lt;p&gt;波括弧を用いることのもう一つのメリットとして &lt;strong&gt;精度が落ちる変換(narrowing conversion)&lt;/strong&gt; を認めない
という特徴がある。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;cpp&quot;&gt;&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;double&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; z&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; sum&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; y &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; z &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// error!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これは &lt;strong&gt;最も厄介な構文解析(most vexing parse)&lt;/strong&gt; と呼ばれる問題を回避できる。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;cpp&quot;&gt;&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;Widget &lt;span class=&quot;token function&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;// call Widget ctor with argument 10&lt;/span&gt;
Widget &lt;span class=&quot;token function&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;token comment&quot;&gt;// declares a function named w2 that returns a Widget&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;波括弧の初期化子のデメリットはstd::initializer_listをとみなせる仮引数が渡された際に、
見た目ではより高く一致するコンストラクタが他にあってもstd::initializer_listをとるコンストラクタに
解決されてしまうことである。
これは混乱を生む場合がある。&lt;/p&gt;
&lt;p&gt;丸括弧と波括弧の選択が生む差異の例としては下記のようなものもある。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;cpp&quot;&gt;&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;vector&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;// [5, 5, 5]&lt;/span&gt;

std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;vector&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; v2&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;// [3, 5]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;結局波括弧ではないと初期化できないものがある一方、丸括弧を用いないと混乱を招く初期化もあり、
どちらの方を使うべきということはない。
開発ルールを定めることが肝要である。&lt;/p&gt;
&lt;p&gt;ただし、他社が利用する可能性のあるライブラリの
テンプレート関数内でのオブジェクト作成に際しては関数の挙動自体が左右されてしまうので
単なる開発ルールにとどまらずよく吟味する必要がある。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec32&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;nullptr&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;0とNULLは常にint型である&lt;/strong&gt;。&lt;br&gt;
0やNULLをヌルポインタとして利用するしかなかったが、nullptrが実装されたためその必要性は無くなった。&lt;br&gt;
&lt;strong&gt;nullptrはポインタ型である。&lt;/strong&gt;&lt;br&gt;
そのためオーバーロードで妙な解決をされることもない。
常にnullptrを使用すべきである。&lt;/p&gt;
&lt;p&gt;ただし、これまでと違いnullptrがあるからと言って汎整数型とポインタ型のオーバーロードを行うと
これまで動作していた呼び出し側で意図しないオーバーロード解決されてしまうことになりかねないので注意する。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec33&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;エイリアス宣言&lt;/h4&gt;
&lt;p&gt;長ったらしい型宣言を簡略化する際のtypedefの上位互換としてエイリアス宣言が実装された。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;cpp&quot;&gt;&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;typedef&lt;/span&gt; std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;unique_ptr&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;unordered_map&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;string&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;string&lt;span class=&quot;token operator&quot;&gt;&gt;&gt;&lt;/span&gt; UPtrMapSS&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;using&lt;/span&gt; UPtrMapSS &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;unique_ptr&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;unordered_map&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;string&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;string&lt;span class=&quot;token operator&quot;&gt;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;


&lt;span class=&quot;token keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;FP&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;string&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;using&lt;/span&gt; FP &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;string&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;typedefはテンプレート化に対応していないが、エイリアス宣言は対応しているため、気持ちの悪いネストをする必要がなくなった。&lt;/p&gt;
&lt;p&gt;また、エイリアステンプレートを用いれば、「::type」や「typename」を排除できる。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec34&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;scoped enum&lt;/h4&gt;
&lt;p&gt;C++98まではenum型はスコープを持たなかった。
C++11ではこれが是正され、スコープを持つenum型が導入された。
scoped enumの宣言は &lt;code class=&quot;language-text&quot;&gt;enum class&lt;/code&gt; と表記する。&lt;/p&gt;
&lt;p&gt;単にスコープを持ち名前空間を汚さないようになっただけでなく、
列挙子が暗黙に他の型に変換されることもなくなった。
これまでのように列挙子を数値等と比較したい場合はキャストを利用する。&lt;/p&gt;
&lt;p&gt;enumでは基礎とする方の指定が可能である。
スコープを持つenumの基礎とする型のdefaultはintである。
スコープを持たないenumはdefaultが存在しない。
enumの前方宣言は基礎とする型が存在する場合可能である。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec35&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;未定義private関数の撲滅&lt;/h4&gt;
&lt;p&gt;未定義の関数を呼び出し側に使用されたくない際、C++98ではprivateな関数とすることで秘匿にしていた。
C++11以降ではprivateとして間接的に使用を禁止するのではなく &lt;strong&gt;deleteされた関数 (deleted function)&lt;/strong&gt;
とすることで上記の要件を満たすことができる。
加えて、deleteを利用した場合はコンパイル時に不正なアクセスを検知できる。
private宣言のものをfriend関数内から利用しようとした際などはリンク時まで不正なアクセスを発見できない。&lt;/p&gt;
&lt;p&gt;また、非メンバ関数、テンプレートのインスタンス化も含め、どんな関数でもdeleteできる。&lt;/p&gt;
&lt;p&gt;以上より、使用を禁止したい関数に対してはdeleteを使用する。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;cpp&quot;&gt;&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;isLucky&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a id=&quot;sec36&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;overrideの宣言&lt;/h4&gt;
&lt;p&gt;オーバーライドを実装したい場合、オーバーライドを満たす様にクラスおよびメンバ関数を実装すれば
自動的にメンバ関数がオーバーライドされる。
しかしこの仕様には問題点もあり、
大きなものの一つがオーバーライドしたつもりができていない場合があることだ。
しかもその誤りをコンパイラは教えてくれない。&lt;/p&gt;
&lt;p&gt;上述の問題点を回避するためにC++11以降ではオーバーライドしたい関数には明示的に &lt;code class=&quot;language-text&quot;&gt;override&lt;/code&gt; 宣言を用いる。&lt;/p&gt;
&lt;p&gt;override宣言にはコンパイラ、実装者へのオーバーライドの明示化以外に、
メンバ関数の参照修飾子を用いると左辺値オブジェクトと右辺値オブジェクトを
区別することができるというメリットもある。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec37&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;const_iterator&lt;/h4&gt;
&lt;p&gt;一般に可能な場面ではtuneniconstを使用せよと言われており、iteratorでもそれは例外ではない。
const_iteratorとはSTLが用意したconstをさすポインタ相当のiteratorであり
可能な場面ではこれを使用すべきである。&lt;/p&gt;
&lt;p&gt;C++98でもC++11でも上記のルールは適用されるが、C++98でのconst_iteratorは扱いが煩雑だ。
C++11ではこれが大幅に改良されており現実的に上述のルールに従うことが可能になった。&lt;/p&gt;
&lt;p&gt;よって常にiteratorよりもconst_iteratorを優先して使用する。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec38&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;noexcept, constexpr&lt;/h4&gt;
&lt;h5&gt;noexcept&lt;/h5&gt;
&lt;p&gt;C++11では、関数が例外を発生させないことをnoexceptにより明示できる。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;cpp&quot;&gt;&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;noexcept&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;C++11からプログラムの仕様が変更され、&lt;code class=&quot;language-text&quot;&gt;noexcept&lt;/code&gt; を指定することでコンパイラが最適化する機会が生まれる。&lt;/p&gt;
&lt;h5&gt;constexpr&lt;/h5&gt;
&lt;p&gt;ある変数がコンパイル時定数を必要とする場面で使用可能なことをコンパイラに保証してもらうために
constexprが存在する。&lt;/p&gt;
&lt;p&gt;可能な場面では常にconstexprを使用することで実行時ではなくコンパイル時に可能な範囲の演算が行われ、
処理が軽やかになる。&lt;/p&gt;
&lt;p&gt;注意点はconstexprの宣言を解除すると呼び出し側で大量のエラーが発生する可能性があることだ。
constexprを宣言した後は以降constexpr宣言を削除しないと断ぜられる様にすることに留意する。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;sec39&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;要素の挿入, 直接配置&lt;/h4&gt;
&lt;p&gt;std::vectorに要素を追加する時、一般的に使用される関数はpush_backである。
しかし、emplace_backを使用した方が効率良い場面がある。&lt;/p&gt;
&lt;p&gt;原則として挿入関数と比べ、同等機能の直接配置関数が効率性に優れることはあるが劣ることはない。
ただし、挿入関数なら拒否する様な型変換でも直接配置関数は実行する場合がある。&lt;/p&gt;
&lt;p&gt;直接配置関数が実際に高速に実行されるのは下記の場合である。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;追加する値がコンテナ内に代入ではなくコンストラクトされる&lt;/li&gt;
&lt;li&gt;実引数の型がコンテナ要素の型とは異なる&lt;/li&gt;
&lt;li&gt;コンテナが重複すを理由に値の追加を拒否しない&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Pythonの環境構築奮闘記 あるいは降参の反省文]]></title><description><![CDATA[Python の環境構築はツールが多すぎる]]></description><link>https://dondakeshimo.github.io/tech-blog/blog/python-env</link><guid isPermaLink="false">https://dondakeshimo.github.ioblog/python-envPythonの環境構築奮闘記 あるいは降参の反省文</guid><dc:creator><![CDATA[dondakeshimo]]></dc:creator><pubDate>Sun, 16 Jun 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;モチベーション&lt;/h1&gt;
&lt;p&gt;Pythonは最高だ！
コードの見た目は綺麗で，3rdパーティモジュールも豊富，
何よりもiPython kernelの存在が大きいと思う．
もっというとJupyterだ．
あるいばHydrogen(Atom package)だ．
ブラウザでもお好きなブラウザでもコードを書きながら即時実行できる強みは計り知れない．&lt;/p&gt;
&lt;p&gt;しかし，Pythonの環境構築周辺はとっちらかっている．
議論もベストプラクティスもハゲ散らかっている．
Pythonの環境構築について思い悩んだ挙句，
一旦思考をまとめるのと思考の記録を残す目的で本ログを残す．
(注: ほぼポエム)&lt;/p&gt;
&lt;h1&gt;現状の考察&lt;/h1&gt;
&lt;h3&gt;環境構築ツール&lt;/h3&gt;
&lt;p&gt;下記サイトなど色々なサイトでまとめられているため，まとめのまとめレベルで記述する．&lt;/p&gt;
&lt;p&gt;[https://qiita.com/KRiver1/items/c1788e616b77a9bad4dd#pipenv:title]&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;&lt;/th&gt;
&lt;th&gt;Pythonバージョン切り替え&lt;/th&gt;
&lt;th&gt;パッケージ切り替え&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;pyenv&lt;/td&gt;
&lt;td&gt;◯&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;pyenv-virtualenv&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;◯&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;venv&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;◯&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;virtualenv&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;◯&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;pipenv&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;◯&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;anaconda&lt;/td&gt;
&lt;td&gt;◯&lt;/td&gt;
&lt;td&gt;◯&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;docker&lt;/td&gt;
&lt;td&gt;◯&lt;/td&gt;
&lt;td&gt;◯&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;必要事項&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Pythonバージョンの使い分け&lt;/li&gt;
&lt;li&gt;Python仮想環境の独立性&lt;/li&gt;
&lt;li&gt;Python仮想環境の再現性及び手軽さ&lt;/li&gt;
&lt;li&gt;開発環境のストレスフリー&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ここでPython仮想環境とはvirtual envやpipenvで作成した環境を指す．&lt;/p&gt;
&lt;h5&gt;Pythonバージョンの使い分け&lt;/h5&gt;
&lt;p&gt;絶対に必要がどうかは疑わしいという議論もある．
しかし，導入自体はツールさえインストールしてしまえば簡単にでき，
tensorflowなどのPythonバージョンに依存するモジュール(知識が古かったらすみません)
も容易に使えるようになることや，
実行環境のPythonバージョンが固定されている時のことなども考えると
あって損はない機能というか，やっぱり必要機能だと感じる．&lt;/p&gt;
&lt;h5&gt;Python仮想環境の独立性&lt;/h5&gt;
&lt;p&gt;これはどこまで仮想環境を切り分けるかという話である．
例えば，pyenvのみを用いた場合はバージョン毎の切り分けは可能だが，
プロジェクト単位での環境の切り分けはできない．
しかし，プロジェクトの依存関係がはっきりしないプロジェクトというのは，
個人開発の域を出た瞬間になんとも言えない不安感を煽る．
イケてないと感じるし，イケてない人だと苦笑いされるのは最悪の気分だ．&lt;/p&gt;
&lt;h5&gt;Python仮想環境の再現性及び手軽さ&lt;/h5&gt;
&lt;p&gt;上述の独立性を担保する上で，留意しておきたい点がこの二つである．
独立性を担保し，依存関係がはっきりしていることは非常に好ましいが，
さらにその仮想環境を違うマシン，環境でも簡単にサクッと再現できる必要がある．
著者は古くからの &lt;code class=&quot;language-text&quot;&gt;requirements.txt&lt;/code&gt; はとても好きだ．
Simple is best だ．
逆に自分にとって手軽だろうが，自前のシェルスクリプトなどは再現性が下がるので論外となる．&lt;/p&gt;
&lt;h5&gt;開発環境のストレスフリー&lt;/h5&gt;
&lt;p&gt;ざっくり分けて環境には2種類あり，
それぞれ開発環境と実行環境に分けられる．
ここで議論している環境は実行環境を大きく意識した開発環境を整えることである．
しかし，実行環境のために開発環境の便利さをトレードオフさせることは避けたい，いやだ，ありえない．&lt;/p&gt;
&lt;h5&gt;欲しい環境のまとめ&lt;/h5&gt;
&lt;p&gt;実行環境を意識した上で，バージョンと依存関係がプロジェクト単位で独立しており，
その仮想環境を他の環境でも容易に再構築できるが，
それら全ては開発環境の機能を損なうものであってはならない．&lt;/p&gt;
&lt;h1&gt;ベストプラクティスの考察&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Atom(+ Hydrogen)が好きです&lt;/li&gt;
&lt;li&gt;pipenv, venv, virtualenv, pyenv-virtualenv だとやはり...&lt;/li&gt;
&lt;li&gt;anacondaに委ねる&lt;/li&gt;
&lt;li&gt;docker等，上位の仮想環境で戦う&lt;/li&gt;
&lt;li&gt;pyenv + pyenv-virtualenv はやっぱりありでは&lt;/li&gt;
&lt;li&gt;pyenv + pipenv は次世代みがある&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Atom(+ Hydrogen)が好きです(ポエム強め)&lt;/h3&gt;
&lt;p&gt;いきなり個人の趣向が入ってきて，ベストプラクティス(笑)になってしまった．
Atom + HydrogenはAtomエディタ上でiPythonを用い，
各行実行や，セクション実行が可能なプラグインである．
布教が目的とかではないけど是非使ってみてほしい．惚れると思う．&lt;/p&gt;
&lt;p&gt;さて，このプラグインを実行するためにはJupyter環境が必要になるのだが，これが曲者である．
Jupyter入れるだけでしまいやん！とはならない．
上記の必要事項にプロジェクト毎の独立性と書いたが，
その要件を満たした場合，Hydrogenの実行カーネルを
それぞれのプロジェクトに対して変更する必要がある．
...だが，無理だ．
そのような機能は，ない．
管理手法がそれぞれ異なるのにそのような出すぎた要求はできない．&lt;/p&gt;
&lt;p&gt;そのため，筆者はどのプロジェクトでも使える共通の，なんでも入りの仮想環境を一つ作り，
そのカーネルをHydrogenに登録して用いている．
どう考えても，実行環境と開発環境に乖離が生じているためダメだろうという構成である．
仮想環境は最後にその構成で動くかどうか確認し，他人と共有する為のものと化してしまっている．&lt;/p&gt;
&lt;p&gt;Jupyterで開発している人もどうしているのだろうか．
全てのプロジェクトにJupyter入れているんだろうか？&lt;/p&gt;
&lt;p&gt;Hydrogenを諦めればなんでも綺麗にまとまる気がしてきた．
しかし，必要事項の開発環境のストレスフリーに反する為，
結局筆者はこのような環境を現状使い続けるだろう．
Hydrogenのカーネルを仮想環境毎に割り振るツールでも作れば良いのだろうが...
あれ，それで解決するのでは？
来週の予定，埋まりました．&lt;/p&gt;
&lt;h3&gt;pipenv, venv, virtualenv, pyenv-vritualenv だとやはり...&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;pipenv，ナウいんだろう，知らんけど．&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;という所感を環境構築のリサーチ中に受けた．
これら4つはPythonのバージョン管理は機能として持っておらず，
Python仮想環境の構築にのみ特化したものである．
基本的な機能はどれも同じで，少し前までのデファクトがvirtualenv，
最近評価をあげているのがpipenvという印象である．
正直どれでも良い気もするし，venvには触ったことがないしおすすめ出てこないしで一旦スルーする．&lt;/p&gt;
&lt;p&gt;pipenvはnpm(JavaScriptの似たような機能のやつ)などの影響を受けているらしい？
必要パッケージだけでなくその依存モジュールまで記録してくれる．
npmのようにその環境独自のコマンドを用意することもできる．
最も後発で，機能としては最も完璧に近いと思う．
ただ，遅い．依存関係の記録が異常に遅い．ついでに毎回最初に
&lt;code class=&quot;language-text&quot;&gt;pipenv run&lt;/code&gt; つけるの面倒くさい．
&lt;code class=&quot;language-text&quot;&gt;pipenv shell&lt;/code&gt; はわかりづらい．&lt;/p&gt;
&lt;p&gt;virtualenvやpyenv-virtualenvは再現性がpipenvと比べて低い．
pipenvでは &lt;code class=&quot;language-text&quot;&gt;pipenv install&lt;/code&gt; の1コマンドで済むところを
それぞれの開発者がrequests.txtに応じて開発環境を構築することが必要となる．
逆に開発者それぞれにpipenvの依存関係が軽減されるということでもある．
pyenv-virtualenvの方が手軽だが，
多数のプロジェクトを抱える場合，環境の中央集中の一括管理であるため取っ散らかる．
virtualenvはactivateするのが面倒だったり，環境の使い回しができないデメリットがある．&lt;/p&gt;
&lt;p&gt;やはり...とかなかった．
一長一短だった．
最初はpipenvに落ち着けるつもりだったけど，
書き始めたらむしろ愚痴の方が出てきたため保留．&lt;/p&gt;
&lt;h3&gt;anacondaに委ねる&lt;/h3&gt;
&lt;p&gt;anacondaは全部やってくれる．
マジで全部．本当に全部．全然全部．
以前はWindows環境の場合，その他のツールが動かないため，
anaconda以外の選択肢がなかったし，
実際これさえあればかなりほぼ全ての要求に答えることができる．
じゃあ，これでええやん！とならないのがややこしいところである．&lt;/p&gt;
&lt;p&gt;anacondaそのものの是非について&lt;/p&gt;
&lt;p&gt;[https://team-6.hatenablog.jp/entry/2017/08/24/040451]&lt;/p&gt;
&lt;p&gt;この辺に議論が書いてある．
多分批判点(メリット)をざっくりまとめると&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;権限周りの危険が危ない説がある&lt;/li&gt;
&lt;li&gt;大量のパッケージを入れられて容量とかうざい(大量のパッケージ美味しい)&lt;/li&gt;
&lt;li&gt;pipと競合する(condaの方が楽にインストールできるものも存在する(した))&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この辺に突っ込むと長くなりそうだし，完全に把握しているわけではないからこの辺で飛ばす．
現状，anacondaを使うなら全てをanacondaに委ねる覚悟が必要そう．
何かと共存させるのはどうなんだろうという状態らしい．
筆者はpyenvでanacondaをインストールして使っていたが，
これは大量のパッケージが事前に入っていて便利だったからである．
その程度の理由ならとっととanacondaから撤退した方が吉だろうと思い，全部捨てた．&lt;/p&gt;
&lt;h3&gt;docker等，上位の仮想環境で戦う&lt;/h3&gt;
&lt;p&gt;docker最高！Vagrandとかでも全然あり！
速度のオーバーヘッドはあまりないし，ここまで仮想化したら実行環境への意識という点では完璧だ．
...だが，弊環境では難しい．
一つ大きな理由がマシンの容量が怖いところである．
メインマシンがストレージ256GBのMacなのが全部悪い．
もう一つ運用できないため実際にぶち当たったことはないのだが，
開発環境でストレスが出るのではないかという懸念もある．
できればAtomで開発したいのだが，この場合ボリュームを結合するか，
何かの都度書いたスクリプトをdocker環境にコピーする必要がある．
jupyterサーバを立てる手もあるため，
そこで下書きをしながらスクリプトを書いてコピーという流れが良いのだろうか．
マシンをアップグレードすれば非常に興味のある構成なので是非ご教授願いたい．&lt;/p&gt;
&lt;h3&gt;pyenv + pyenv-virtualenv はやっぱりありでは&lt;/h3&gt;
&lt;p&gt;筆者が最近環境を再考するまで使用していた構成である．
そしてこの投稿を書きながら，Hydrogenを使うに最も適当な構成であると気づき．
再度この構成に落ち着かんとしている．
問題としては環境の再現性が大きいと思うし，
実際のところpipenvの方がイケてる感は否めないので他人に勧めるようなものでもない．&lt;/p&gt;
&lt;h3&gt;pyenv + pipenv は次世代みがある&lt;/h3&gt;
&lt;p&gt;目下ネット上の第一おすすめ候補だろう．
かっこいいし，いいと思う．
遅い問題については &lt;code class=&quot;language-text&quot;&gt;--skip lock&lt;/code&gt; オプションをつけることで大きく軽減されるらしい．
それでもどこかのタイミングでlockせざるを得ないが．
この問題についてはpipenvの開発者も認識しているらしく，近い将来改善されることが期待される．
もう一つの仮想環境に入るの面倒あるいわかりづらい問題は，
自分のターミナルを適応させることでなんとかなると思う．
というかそういうの考えるのは割と好き．&lt;/p&gt;
&lt;h1&gt;まとめ&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;開発環境さえ整えばdockerが最高！(と思う)&lt;/li&gt;
&lt;li&gt;パッケージ管理特化のツールはpipenvが一つ抜けている気もするが，(まだ)五十歩百歩&lt;/li&gt;
&lt;li&gt;anacondaは好き嫌い分かれてる&lt;/li&gt;
&lt;li&gt;開発環境を完璧に整えるのはdockerに限らず難しい&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item></channel></rss>