{"pageProps":{"post":{"title":"エリック・エヴァンスのドメイン駆動設計をまとめる","date":"2021-05-18","slug":"2021-05-18-evans_eric_ddd","author":{"name":"JJ Kasper","picture":"/assets/blog/authors/jj.jpeg"},"content":"<h1 id=\"目次\">目次</h1>\n<ul>\n<li><a href=\"#%E5%8B%95%E6%A9%9F\">動機</a></li>\n<li><a href=\"#%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E9%A7%86%E5%8B%95%E8%A8%AD%E8%A8%88\">ドメイン駆動設計</a>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E9%A7%86%E5%8B%95%E8%A8%AD%E8%A8%88%E3%81%AE%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%94%A8%E6%B3%95\">ドメイン駆動設計の基本的用法</a></li>\n<li><a href=\"#%E3%83%A6%E3%83%93%E3%82%AD%E3%82%BF%E3%82%B9%E8%A8%80%E8%AA%9E\">ユビキタス言語</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E8%A8%AD%E8%A8%88%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E6%A7%8B%E6%88%90%E8%A6%81%E7%B4%A0\">設計における構成要素</a>\n<ul>\n<li><a href=\"#%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3\">アーキテクチャ</a>\n<ul>\n<li><a href=\"#%E3%83%AC%E3%82%A4%E3%83%A4%E3%83%BC%E3%83%89%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3\">レイヤードアーキテクチャ</a></li>\n<li><a href=\"#%E5%88%A9%E5%8F%A3%E3%81%AAui\">利口なUI</a>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E5%88%A9%E7%82%B9\">利点</a></li>\n<li><a href=\"#%E6%AC%A0%E7%82%B9\">欠点</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88\">オブジェクト</a>\n<ul>\n<li><a href=\"#entities-reference-objectes\">ENTITIES (REFERENCE OBJECTES)</a></li>\n<li><a href=\"#value-objects\">VALUE OBJECTS</a></li>\n<li><a href=\"#services\">SERVICES</a></li>\n</ul>\n</li>\n<li><a href=\"#%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB-%E3%83%91%E3%83%83%E3%82%B1%E3%83%BC%E3%82%B8\">モジュール (パッケージ)</a></li>\n<li><a href=\"#%E3%83%A9%E3%82%A4%E3%83%95%E3%82%B5%E3%82%A4%E3%82%AF%E3%83%AB\">ライフサイクル</a>\n<ul>\n<li><a href=\"#%E9%9B%86%E7%B4%84\">集約</a></li>\n<li><a href=\"#%E3%83%95%E3%82%A1%E3%82%AF%E3%83%88%E3%83%AA\">ファクトリ</a>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E3%83%95%E3%82%A1%E3%82%AF%E3%83%88%E3%83%AA%E3%81%AE%E9%85%8D%E7%BD%AE%E5%A0%B4%E6%89%80\">ファクトリの配置場所</a></li>\n<li><a href=\"#%E3%83%95%E3%82%A1%E3%82%AF%E3%83%88%E3%83%AA%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%95%E3%82%A7%E3%83%BC%E3%82%B9\">ファクトリのインタフェース</a></li>\n<li><a href=\"#%E4%B8%8D%E5%A4%89%E6%9D%A1%E4%BB%B6%E3%81%AE%E7%AE%A1%E7%90%86\">不変条件の管理</a></li>\n<li><a href=\"#%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E5%86%8D%E6%A7%8B%E6%88%90\">オブジェクトの再構成</a></li>\n<li><a href=\"#%E3%81%BE%E3%81%A8%E3%82%81\">まとめ</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E3%83%AA%E3%83%9D%E3%82%B8%E3%83%88%E3%83%AA\">リポジトリ</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E3%83%AA%E3%83%95%E3%82%A1%E3%82%AF%E3%82%BF%E3%83%AA%E3%83%B3%E3%82%B0\">リファクタリング</a>\n<ul>\n<li><a href=\"#specification\">SPECIFICATION</a>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E6%A4%9C%E8%A8%BC\">検証</a></li>\n<li><a href=\"#%E9%81%B8%E6%8A%9E\">選択</a></li>\n<li><a href=\"#%E8%A6%81%E6%B1%82\">要求</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E8%A8%AD%E8%A8%88\">設計</a></li>\n<li><a href=\"#%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3\">デザインパターン</a>\n<ul>\n<li><a href=\"#strategy-policy\">STRATEGY (POLICY)</a></li>\n<li><a href=\"#composite\">COMPOSITE</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E6%88%A6%E7%95%A5%E7%9A%84%E8%A8%AD%E8%A8%88\">戦略的設計</a>\n<ul>\n<li><a href=\"#%E3%83%A2%E3%83%87%E3%83%AB%E3%81%AE%E6%95%B4%E5%90%88%E6%80%A7%E7%B6%AD%E6%8C%81\">モデルの整合性維持</a>\n<ul>\n<li><a href=\"#%E5%A2%83%E7%95%8C%E3%81%A5%E3%81%91%E3%82%89%E3%82%8C%E3%81%9F%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88\">境界づけられたコンテキスト</a></li>\n<li><a href=\"#%E5%85%B1%E6%9C%89%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB\">共有カーネル</a></li>\n<li><a href=\"#%E9%A1%A7%E5%AE%A2%E6%8F%90%E4%BE%9B%E8%80%85-customersupplier\">顧客/提供者 (CUSTOMER/SUPPLIER)</a></li>\n<li><a href=\"#%E9%A0%86%E5%BF%9C%E8%80%85-conformist\">順応者 (CONFORMIST)</a></li>\n<li><a href=\"#%E8%85%90%E6%95%97%E9%98%B2%E6%AD%A2%E5%B1%A4-anticorruption-layer\">腐敗防止層 (ANTICORRUPTION LAYER)</a></li>\n<li><a href=\"#%E5%85%AC%E9%96%8B%E3%83%9B%E3%82%B9%E3%83%88%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9\">公開ホストサービス</a></li>\n<li><a href=\"#%E5%85%AC%E8%A1%A8%E3%81%95%E3%82%8C%E3%81%9F%E8%A8%80%E8%AA%9E\">公表された言語</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%92%B8%E7%95%99\">蒸留</a>\n<ul>\n<li><a href=\"#%E3%82%B3%E3%82%A2%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3\">コアドメイン</a></li>\n<li><a href=\"#%E6%B1%8E%E7%94%A8%E3%82%B5%E3%83%96%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3\">汎用サブドメイン</a></li>\n<li><a href=\"#%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E3%83%93%E3%82%B8%E3%83%A7%E3%83%B3%E5%A3%B0%E6%98%8E%E6%96%87\">ドメインビジョン声明文</a></li>\n<li><a href=\"#%E5%BC%B7%E8%AA%BF%E3%81%95%E3%82%8C%E3%81%9F%E3%82%B3%E3%82%A2\">強調されたコア</a></li>\n<li><a href=\"#%E9%9A%94%E9%9B%A2%E3%81%95%E3%82%8C%E3%81%9F%E3%82%B3%E3%82%A2\">隔離されたコア</a></li>\n<li><a href=\"#%E6%8A%BD%E8%B1%A1%E5%8C%96%E3%81%95%E3%82%8C%E3%81%9F%E3%82%B3%E3%82%A2\">抽象化されたコア</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%A4%A7%E8%A6%8F%E6%A8%A1%E3%81%AA%E6%A7%8B%E9%80%A0\">大規模な構造</a>\n<ul>\n<li><a href=\"#%E8%B2%AC%E5%8B%99%E3%81%AE%E3%83%AC%E3%82%A4%E3%83%A4\">責務のレイヤ</a></li>\n<li><a href=\"#%E7%9F%A5%E8%AD%98%E3%83%AC%E3%83%99%E3%83%AB\">知識レベル</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"動機\">動機</h1>\n<p>ソフトウェアエンジニア界で活動をしている人なら誰しもが聞いたことはあろう\n<a href=\"https://www.amazon.co.jp/%E3%82%A8%E3%83%AA%E3%83%83%E3%82%AF%E3%83%BB%E3%82%A8%E3%83%B4%E3%82%A1%E3%83%B3%E3%82%B9%E3%81%AE%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E9%A7%86%E5%8B%95%E8%A8%AD%E8%A8%88-Architects%E2%80%99Archive-%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA%E3%81%AE%E5%AE%9F%E8%B7%B5-%E3%82%A8%E3%83%AA%E3%83%83%E3%82%AF%E3%83%BB%E3%82%A8%E3%83%B4%E3%82%A1%E3%83%B3%E3%82%B9/dp/4798121967/ref=tmm_other_meta_binding_swatch_0?_encoding=UTF8&#x26;qid=&#x26;sr=\">エリック・エヴァンスのドメイン本</a>\n私もようやくその本の価値が分かる時分になり、手にとった。\nどうやら考えていたよりも幾分実験的な内容で、体系だっているようで煩雑としている印象を受けたが、\n如何せん書かれていることは設計を行う人間にとっては不可欠な内容と思える物ばかりで、\n是非とも自分のものにしたいという思いからエッセンスのみを <em>自分のために</em> まとめる。</p>\n<h1 id=\"ドメイン駆動設計\">ドメイン駆動設計</h1>\n<h3 id=\"ドメイン駆動設計の基本的用法\">ドメイン駆動設計の基本的用法</h3>\n<ol>\n<li>モデルと設計の核心が相互に形成し合う</li>\n<li>モデルは、チームメンバ全員が使用する言語の基盤である</li>\n<li>モデルとは、蒸留された知識である</li>\n</ol>\n<h3 id=\"ユビキタス言語\">ユビキタス言語</h3>\n<p>ドメインエキスパートが使用する専門用語とソフトウェアエンジニアが使用する言語は共通化する必要がある。\nこの共通化された言語を <strong>ユビキタス言語</strong> という。</p>\n<p>ユビキタス言語の語彙にはクラスや主要な操作の名前が含まれている。\n開発チームは試行錯誤の上で、用語や用語の組み合わせがぎこちない場所を発見した場合、その代わりとなる表現を探す。\n言語に対するこのような変更はドメインモデルに対する変更として認識される。\nドメインモデルは言語の骨格として使用されることになり、モデルはユビキタス言語を反映したものにならなければならない。\nその上で、チーム内の全てのコミュニケーションとコードにおいて、その言語を厳格に用いることをチームに約束させることが重要である。</p>\n<blockquote>\n<p>ユビキタス言語における変更は、モデルに対する変更であると認識すること。</p>\n</blockquote>\n<p>モデルが言語の骨格となるが、それに異議を唱えるのはもちろん開発チームのみでなくドメインエキスパートも同様にすべきである。\n(むしろその方が多いとも思われる。)\nユビキタス言語の使いにくさ、ぎこちなさはモデルの不整合の発見の一助となる。</p>\n<h1 id=\"設計における構成要素\">設計における構成要素</h1>\n<h2 id=\"アーキテクチャ\">アーキテクチャ</h2>\n<h3 id=\"レイヤードアーキテクチャ\">レイヤードアーキテクチャ</h3>\n<p>ドメインモデルの隔離と依存関係の整理のためにレイヤードアーキテクチャが用いられる。\n代表的な例としてMVCモデルが挙げられる。\n本書で紹介されているレイヤーについて確認すると</p>\n<ul>\n<li>ユーザインタフェース層(プレゼンテーション層)\n<ul>\n<li>外部との接続部分</li>\n</ul>\n</li>\n<li>アプリケーション層\n<ul>\n<li>ソフトウェアが行うべき処理を定義する</li>\n<li>ドメインオブジェクトを使用して問題を解決する</li>\n<li>ビジネスルールや知識を含まない</li>\n<li>ビジネスの状態は持たないが作業の進捗などの情報は持っても良い</li>\n</ul>\n</li>\n<li>ドメイン層(モデル層)\n<ul>\n<li>ビジネスの概念とビジネスの状態、ルールを管理する</li>\n<li>状態の永続化などの技術的詳細はインフラストラクチャ層に委譲する</li>\n</ul>\n</li>\n<li>インフラストラクチャ層\n<ul>\n<li>ドメイン層だめの永続化、ユーザインタフェースのウェジェット描画など技術的詳細を提供する</li>\n</ul>\n</li>\n</ul>\n<p>本書におけるレイヤードアーキテクチャの本質はドメインモデルの隔離に尽きると言える。\nドメイン層を技術的詳細やその他詳細と疎結合にすることで、ドメインモデルはドメインモデルのみに集中することができる。</p>\n<h3 id=\"利口なui\">利口なUI</h3>\n<p>上記のドメインモデルに集中する本懐を鑑みると表題はおかしな言葉に見えるし、\n実際ドメイン駆動設計において、利口なUIはアンチパターンである。\nしかし、フロントエンド開発の現状を考えるとしっかりとその長短について見つめ直す必要があろう。\nもちろん複雑なビジネスロジックを含むフロントエンド開発においては単なるUIとしての機能というよりは、\nそれ一つでソフトウェアとみなせるため、内部でドメイン駆動設計を行うという選択肢もあるが、\nここでいうUIとは最も外部に位置するクラスであり、\nReactでいうpageごとのMainコンポーネントがそれに当たると考えて良いと思われる。</p>\n<h5 id=\"利点\">利点</h5>\n<ul>\n<li><strong>単純なアプリケーションの場合</strong> 、生産性が高くすぐに作れる</li>\n<li>アーキテクチャに対する造詣が浅くても問題ない</li>\n<li>単純な機能追加は簡単で、見積もりも簡単である</li>\n</ul>\n<h5 id=\"欠点\">欠点</h5>\n<ul>\n<li>アプリケーションの統合は困難である</li>\n<li>振る舞いの再利用が難しい</li>\n<li>複雑な機能追加を行うとアプリケーションもまた複雑化していく</li>\n</ul>\n<h2 id=\"オブジェクト\">オブジェクト</h2>\n<h3 id=\"entities-reference-objectes\">ENTITIES (REFERENCE OBJECTES)</h3>\n<p>同一性によって定義されるオブジェクトのことをエンティティと呼ぶ。\nエンティティは属性よっては定義されず、同じ属性を保有していても他のオブジェクトと区別される必要があり、\n属性が変化したとしても同一性が損なわれてはならない。</p>\n<p>エンティティの考え方として代表的なものを考えると「人間」という概念が挙げられる。\n身長体重などの属性はいくらでも変化するが私が私であることは変わらない(本当かは正直知らないが)。</p>\n<p>モデルでエンティティを定義する際に留意することを下記に示す。</p>\n<ul>\n<li>同一性を第一とすること</li>\n<li>クラスの定義をシンプルに保ち、ライフサイクルの連続性と同一性に集中すること</li>\n<li>形式や履歴に関係なく、各オブジェクトを識別する手段を定義すること</li>\n<li>オブジェクト同士を属性によって突き合わせる要件には注意すること</li>\n<li>各オブジェクトに対して結果が保証される操作を定義すること\n<ul>\n<li>ユニークな文字列が代表的な解決策ではある</li>\n<li>ユニークな文字列を使用するか否かにかかわらず、モデルが同じであるとは何を意味するかを定義する必要がある</li>\n<li>一度識別子を決定したら決して変更してはならない</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"value-objects\">VALUE OBJECTS</h3>\n<p>あるモデル要素についてその属性にのみ関心が集中し、同一性が必要ないオブジェクトを値オブジェクトと呼ぶ。\nエンティティと異なり、同じ属性を保有しているオブジェクト同士に区別は必要なく同一のものであると見なす。</p>\n<ul>\n<li>同一性を与えない</li>\n<li>不変なモデルとして設計する\n<ul>\n<li>FLYWEIGHTパターンなど考慮が非常に楽である</li>\n<li>ただし多くの言語でサポートされている概念ではないので開発ルールとして開発者が遵守する必要がある</li>\n</ul>\n</li>\n</ul>\n<p>値オブジェクトに対して可変性を持たせる場合もあるが、可能ならば回避する性質である。\n可変性が生じた場合はその値オブジェクトは共有してはならない。</p>\n<h3 id=\"services\">SERVICES</h3>\n<p>ドメインエキスパートとの会話から生まれる概念の中には、本質的に活動や行動、操作であって、\nオブジェクトとしてモデル化すると不自然なものがある。\nこれらの概念は無理にオブジェクトとしてモデル化せずドメインサービスとしてモデル化することができる。\nサービスとは、モデルにおいて独立したインタフェースとして提供される操作であり、カプセル化されない。\n良く設計されたサービスの特徴として</p>\n<ul>\n<li>操作がドメインの概念に関係しており、その概念がドメインオブジェクトの自然な一部ではない</li>\n<li>引数と返り値、つまりインタフェースはドメインオブジェクトで定義されている</li>\n<li>操作に状態がない</li>\n<li>ユビキタス言語で操作名が定義されている</li>\n</ul>\n<p>それぞれのレイヤーに属するサービスを\nドメインサービス、アプリケーションサービス、インフラストラクチャサービスと呼ぶことができる。</p>\n<p>ドメイン層にサービスを導入することで、アプリケーション層によるドメイン層の呼び出し処理が簡素化され、\nドメイン層とアプリケーション層の線引きを明確化することができる。</p>\n<h2 id=\"モジュール-パッケージ\">モジュール (パッケージ)</h2>\n<p>モジュール間では低結合、モジュール内では高凝集と言うのは技術的に考えて自明の理だが、\nモジュールは概念についても分断してしまうことを意識する。\nモジュールはユビキタス言語を用いて名付けられるべきであり、\nドメインの概念に従って分割されると同時に対応するコードも独立される状態を目指す。</p>\n<p>フレームワークにただ従ってパッケージングを行った場合、上述のような結果が得られないことも多いので注意する。</p>\n<h2 id=\"ライフサイクル\">ライフサイクル</h2>\n<h3 id=\"集約\">集約</h3>\n<p>集約は複数オブジェクトの集まりを指す言葉であり、トランザクションの単位となる。\n特に複数のオブジェクトに関連する不変条件が存在する時に、シンプルなロックの機構をやたらと使うと\n過度に遅いシステムや、デッドロックが発生するシステムが作成されてしまうため、\nいくつかのオブジェクト間の不変条件を満たすことを容易にするようにグルーピングしたものが集約となる。</p>\n<p>集約において重要な概念は集約ルートと境界である。\n集約ルートとはグローバルな同一性を保持したエンティティであり、外部からの参照を受け付ける集約内部で唯一のオブジェクトとなる。\n境界とは集約内部においてはルートエンティティ以外の参照を持つことは自由だが、集約外部で参照を持たれて良いのは\nルートエンティティのみと言う約束および内部と外部の境目を指す。</p>\n<p>トランザクションの具体的なルールは下記のようになる。</p>\n<ul>\n<li>集約のルートエンティティは、グローバルな同一性をもち、不変条件をチェックする最終的な責務を負う</li>\n<li>境界内部のエンティティは、集約ないのでのみ一意となるローカルな同一性を持つ</li>\n<li>集約の境界外にあるオブジェクトはルートエンティティ以外の境界内のオブジェクト参照を保持できない</li>\n<li>ルートエンティティは境界内部のオブジェクトの参照を返却できるが、境界外部のオブジェクトはその参照を保持してはならない</li>\n<li>上記のルールを満たした場合、データベースから直接取得できるのは集約ルートだけとなる</li>\n<li>削除操作については境界内部に存在するオブジェクトを一度に削除する必要がある</li>\n<li>境界内部に存在するオブジェクトに対する変更が反映される際、必ず集約全体の不変状態を満たすようにしなければならない</li>\n</ul>\n<p>この概念を直接的に用いると言うことは少ないかもしれないが、\nファクトリとリポジトリにおいて対象となるものがここで述べた <strong>集約</strong> となる。</p>\n<h3 id=\"ファクトリ\">ファクトリ</h3>\n<p>オブジェクトのライフサイクルにおいて初期の生成時、または中期の再構成に利用される。\nオブジェクトを利用するクライアントに対して、</p>\n<ul>\n<li>オブジェクトの関連の詳細まで意識させたくない</li>\n<li>オブジェクトの生成に必要な複雑な操作を行わせたくない</li>\n<li>多態的に利用されるオブジェクト群のアクセスポイントを特定させたい</li>\n</ul>\n<p>上記のような要望がある場合はファクトリを利用する。</p>\n<h5 id=\"ファクトリの配置場所\">ファクトリの配置場所</h5>\n<p>対象が集約である場合(これがほとんどの場合であると著者は述べている)、エンティティルートにファクトリメソッドを追加することができる。</p>\n<p>別の例としては、集約の境界外であるが対象オブジェクトを生成する際に支配的なルールを内包しているオブジェクトが\nファクトリメソッドを持つことも自然な設計である。</p>\n<p>また、上記のどちらも自然な設計とは思えない場合は独立したファクトリオブジェクトまたはファクトリサービス\n(どちらも同じものだと思われる)を作成すると言う選択肢も忘れていはならない。</p>\n<h5 id=\"ファクトリのインタフェース\">ファクトリのインタフェース</h5>\n<p>以下の点を念頭において、シグネチャを決定する必要がある。</p>\n<ul>\n<li>各操作はアトミックであり、一度のやり取りで完結する</li>\n<li>失敗時の挙動については事前に取り決めをしておき一貫性を保つ</li>\n<li>ファクトリはその引数と結合する</li>\n</ul>\n<p>特に引数との結合だが、引数として適切なものは</p>\n<ul>\n<li>下位の設計層に由来する基本的なオブジェクト</li>\n<li>密接に関連する(関連せざるを得ない)抽象オブジェクト</li>\n<li>生成物に付与する設定項目</li>\n</ul>\n<h5 id=\"不変条件の管理\">不変条件の管理</h5>\n<p>ファクトリを使用する場合、生成物の不変条件の管理をファクトリで行うか生成物で行うかの選択に迫られる。\n多くの場合、生成されるオブジェクトに不変条件のロジックを記述し、\nファクトリは不変条件の担保を生成オブジェクトに委譲させる形を取れば十分である。\nただし、下記のような条件の場合はファクトリにロジックを移動させることも可能である。</p>\n<ul>\n<li>不変条件のロジックが必要なタイミングがオブジェクト生成時のみである\n<ul>\n<li>値オブジェクト</li>\n<li>エンティティの識別子</li>\n</ul>\n</li>\n<li>集約のルールに関するロジック</li>\n</ul>\n<h5 id=\"オブジェクトの再構成\">オブジェクトの再構成</h5>\n<p>ファクトリをライフサイクル初期の生成に関する操作を扱うものとして見てきたが、オブジェクトの再構成にもファクトリを利用することがある。\n生成に対して再構成を行う場合はより複雑な操作が必要になる場合があるため注意が必要である。\nまた、生成とは2つの点で大きく異なる。</p>\n<ul>\n<li>エンティティのファクトリに関して、新しい追跡IDを割り当てることがない</li>\n<li>不変条件の違反に対して生成時とは別の制御を行う必要がある場合が多い</li>\n</ul>\n<h5 id=\"まとめ\">まとめ</h5>\n<p>インスタンスの生成のアクセスポイントは何かしら必要である、それがコンストラクタであることもあるが、\nファクトリを作成することで複雑な操作や実装の詳細の隠蔽を行えるなどの多大な恩恵を得られることがある。\nファクトリはモデルを表現するものではないが、ドメイン設計の一部であり、モデルを表現するオブジェクトを鮮明にしておく上で役に立つ。\nモデルの一部ではないが、モデルの詳細を知っているアクセスポイントであるため、\n下手な依存関係や密結合を作成しないことや不変条件に対しる責務に対して慎重に設計する必要がある。</p>\n<h3 id=\"リポジトリ\">リポジトリ</h3>\n<p>オブジェクトの再構成において、グローバルに検索を用いてアクセスできるデータベースは非常に有用だが、\nその疎結合せいやグローバル性からドメインオブジェクトや集約ルートが無視されてしまう可能性が残る。\nそのため、ほとんどのオブジェクトではグローバルな検索でアクセスすべきではない。</p>\n<p>グローバルな検索によって再構成されるべきオブジェクトももちろんある。\nただし、クライアントが自由に検索クエリをかけるような状況、あるいは検索における技術的な枠組みを直接扱うような状況に\n陥っている場合、先述のビジネスルールの無視や境界の無視が起こりかねない。\nそのため、クライアントとデータへのアクセス技術との間に <strong>リポジトリ</strong> を挟むことでクライアントのアクセスポイントを限定する。\nその他にもリポジトリを用意することによる恩恵は多数ある。</p>\n<ul>\n<li>クライアントにとって再構成の処理がシンプルになる</li>\n<li>アプリケーションとドメインの設計を永続化技術や複数のデータベース戦略などから分離する</li>\n<li>オブジェクトアクセスに関する設計上の決定を伝える</li>\n<li>テストで使用するために、ダミーの実装で置き換えるのが容易になる</li>\n</ul>\n<h1 id=\"リファクタリング\">リファクタリング</h1>\n<h2 id=\"specification\">SPECIFICATION</h2>\n<p>あるオブジェクトが何らかの基準を満たしているかどうかを判定する述語的な値オブジェクトを仕様オブジェクトという。\n仕様オブジェクトを用いることはある種のパターンである。</p>\n<p>ビジネスルールの中にはどのエンティティ、値オブジェクトの責務にも合致しないものがあり、それらを強引にオブジェクトに含ませることで、\nドメインオブジェクト本来の意味を侵害しかねない。こうした際に仕様オブジェクトとしてビジネスルールを分離することで、\nドメインオブジェクトが保護され、モデルの保守性、表現力が増す。\n仕様の価値は異なるように見えるアプリケーションの機能を統一することにある。\n下記のうち一つでも当てはまる用途があればオブジェクトの状態を定義する必要がある。</p>\n<ul>\n<li>オブジェクトを <strong>検証</strong> して何らかの要求を満たしているか、何らかの目的のための用意ができているか調べる</li>\n<li>コレクションからオブジェクトを <strong>選択</strong> する</li>\n<li>何らかの <strong>要求</strong> に適合する新しいオブジェクトの生成を定義する</li>\n</ul>\n<p>上記の検証、選択、要求に応じた構築という3つの用途を仕様というパターンに当てはめることで、同一のルールとして扱うことができる。</p>\n<h5 id=\"検証\">検証</h5>\n<p>非常に単純な用途であり、作成された仕様オブジェクトは渡された対象オブジェクトが仕様オブジェクトに記述されている\nビジネスルールを満たしているかどうかを確認する。</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">DelinquentInvoiceSpecification</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">InvoiceSpecification</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 当日日付</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">Date</span> currentData<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">DelinquentInvoiceSpecification</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Date</span> currentDate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>currentDate <span class=\"token operator\">=</span> currentDate<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isSatisfiedBy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Invoice</span> candidate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> gracePeriod <span class=\"token operator\">=</span> candidate<span class=\"token punctuation\">.</span><span class=\"token function\">customer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getPaymentGracePeriod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Date</span> firmDeadline <span class=\"token operator\">=</span> <span class=\"token class-name\">DateUtility</span><span class=\"token punctuation\">.</span><span class=\"token function\">addDaysToDate</span><span class=\"token punctuation\">(</span>candidate<span class=\"token punctuation\">.</span><span class=\"token function\">dueDate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> gracePeriod<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> currentDate<span class=\"token punctuation\">.</span><span class=\"token function\">after</span><span class=\"token punctuation\">(</span>firmDeadline<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>また、仕様を述語的に扱うのを容易にするためにコンポジットパターンを適用することも可能である。</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Specification</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">boolean</span> <span class=\"token function\">isSatisfiedBy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> candidate<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token class-name\">Specification</span> <span class=\"token function\">and</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Specification</span> other<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">Specification</span> <span class=\"token function\">or</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Specification</span> other<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">Specification</span> <span class=\"token function\">not</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AbstractSpecification</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Specification</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">Specification</span> <span class=\"token function\">and</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Specification</span> other<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AndSpecification</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> other<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">Specification</span> <span class=\"token function\">or</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Specification</span> other<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">OrSpecification</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> other<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">Specification</span> <span class=\"token function\">not</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NotSpecification</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h5 id=\"選択\">選択</h5>\n<p>検証と同様に選択における条件を仕様オブジェクトに記述する。\n例えば、上記の <code>DelinquentInvoiceSpecification</code> に</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Set</span> <span class=\"token function\">selectSatisfying</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">InvoiceSpecification</span> spec<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>を追加すれば良いだろう。</p>\n<p>ここで留意する必要があるのは、インフラストラクチャ層の責務である技術的詳細をドメイン層に持ち込まないことである。\n逆にビジネスルールをインフラストラクチャ層に流出させないことも同様に重要である。\nO/Rマッパーを使用するかダブルディスパッチを利用するなどして、レイヤを保つこと。</p>\n<h5 id=\"要求\">要求</h5>\n<p>検証、選択が既に存在するオブジェクトに対する仕様であったが、要求は今から生成するオブジェクトに対する仕様である。\nこのオブジェクトを満たすように生成や再構築が行われることとなる。</p>\n<p>同様の事象が扱えるパターンとしてジェネレータがあり、こちらを使用することで受ける恩恵もいくつかあるので\nトレードオフを吟味して考える必要がある。</p>\n<h2 id=\"設計\">設計</h2>\n<ul>\n<li>意図の明白なインタフェース\n<ul>\n<li>副作用のない関数</li>\n<li>表明: 操作の事後条件とクラスと集約の不変条件の宣言</li>\n</ul>\n</li>\n<li>概念の輪郭</li>\n<li>独立したクラス\n<ul>\n<li>閉じた操作</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"デザインパターン\">デザインパターン</h2>\n<h3 id=\"strategy-policy\">STRATEGY (POLICY)</h3>\n<p>プロセスの中で変化する部分を柔軟に変更するためにストラテジーパターンが有効である。\n先述の仕様オブジェクトはStrategyパターンとして扱うことが可能である。</p>\n<p>書籍の具体例を借りると、運搬業務における経路選択において何を最適化するかの仕様を可変部分としてStrategyパターンを組むことができる。\nこの場合、経路選択内では仕様を満たすような経路を探すという作業に集中することができ、\n選択されるべき経路が最も安い経路なのか、最も早い経路なのかなどは考えなくてよくなる。\n選択の仕様を分離することでシステムに柔軟性が生まれていることがわかる。</p>\n<h3 id=\"composite\">COMPOSITE</h3>\n<p>ネストされたコンテナの関係性をモデルに反映する場合コンポジットパターンが有効である。</p>\n<h1 id=\"戦略的設計\">戦略的設計</h1>\n<h2 id=\"モデルの整合性維持\">モデルの整合性維持</h2>\n<h3 id=\"境界づけられたコンテキスト\">境界づけられたコンテキスト</h3>\n<p>モデルが適用されるコンテキストは明確に定義されなければならない。\n明示的な境界は、チーム編成、アプリケーションのようと、コードベースやデータベーススキーマなどの物理的な表現などの観点から設定する。\nコンテキストの名前は当然ユビキタス言語である必要がある。\nモデルに詳しくない人が誤って他のコンテキストの概念を直接扱ったりすることのないように、\nコンテキストマップに代表されるドキュメントがあると良い。</p>\n<h3 id=\"共有カーネル\">共有カーネル</h3>\n<p>コンテキストの境界を跨ぐ概念などはそれぞれのコンテキストを担当するチーム間で合意を得て開発していく必要がある。\nこれらの概念をドメインモデルのサブセットとして共有する手法がある。</p>\n<h3 id=\"顧客提供者-customersupplier\">顧客/提供者 (CUSTOMER/SUPPLIER)</h3>\n<p>二つのシステム間の関係が「上流」と「下流」の関係にある場合、変更に対するオーバーヘッドが生じる場合がある。\n上流のチームは下流のチームに必要だったものを止めてしまわないかと慎重になり、\n下流のチームは上流のチームが新たな情報を与えてくれないとプロジェクトが進まないことがある。\nこの場合は、顧客/提供者の関係であることを明示的な関係性として定義すること。\n上流チームのシステムで下流チームに関係のある部分は下流チームと共同でテストを作成し(受入テスト)、\n継続的な統合の一部として実行するようにする。\nまた、提供者にとって優先されるべきは顧客であるということも取り決める必要がある。</p>\n<h3 id=\"順応者-conformist\">順応者 (CONFORMIST)</h3>\n<p>上流/下流関係の2チームがあったとして先述のように顧客/提供者の関係を築くには上流側に恩恵がない場合、\n下流チームはどうすることもできない。\n上記のような時は下流チームが上流チームに隷属する他ない。\nこのような下流システムを順応者と呼んでいる。</p>\n<h3 id=\"腐敗防止層-anticorruption-layer\">腐敗防止層 (ANTICORRUPTION LAYER)</h3>\n<p>コンテキストの境界におけるインタフェースが膨大になると、コンテキスト内のモデルがインタフェースに合わせてしまうことがある。\nインタフェースはモデルに従属されるべきであり、これはおかしい。\nこの場合は、インタフェースを用のレイヤを作成することで、ドメインモデルを保護する。\nこのレイヤを腐敗防止層と呼ぶ。</p>\n<p>腐敗防止層はファサードバターンとアダプタパターンを合わせて使用することができる。</p>\n<h3 id=\"公開ホストサービス\">公開ホストサービス</h3>\n<p>システム間の関係として、基本的にはサーバーがクライアントの要求に応えるようにインタフェースを定義するが、\nクライアントが多い場合などクライアントの要望に応えるのが難しい場合はサーバー側の主導でインタフェースを定める。\nサーバはアクセするためのプロトコルを定義し公開する。この共有プロトコルは一貫性のある状態に保つ必要がある。</p>\n<h3 id=\"公表された言語\">公表された言語</h3>\n<p>二つのコンテキスト間でモデルをやり取りするには共通の言語が必要になる。\n必要なドメインの情報を公表された共通の媒体を通じて交換するのが良い。\n例えば、化学マークアップ言語(CML: Chemical Markup Language) などがそれにあたる。</p>\n<h2 id=\"蒸留\">蒸留</h2>\n<p>蒸留とは混ざり合ったコンポーネントを分離するプロセスであり、価値があって役立つ形式で本質を抽出するためのものである。</p>\n<h3 id=\"コアドメイン\">コアドメイン</h3>\n<p>ドメインモデルの中でも最も重要なコアドメインを明確にし位置付けることで、開発の優先順位や外部委託の判断などの判断基準となる。</p>\n<h3 id=\"汎用サブドメイン\">汎用サブドメイン</h3>\n<p>ドメインモデルの中で専門的な知識を捉えることも伝えることもなく、複雑さを付け加えるだけの部分もある。\nこのようなサブドメインを識別し分離することで、コアドメインに対してより集中できるようになる。\nまた、専門的な知識に携わっていない部分に関しては汎用性が高い部分ともいえるため、\n既製品や公表されているモデルの採用も視野に入れられる。</p>\n<h3 id=\"ドメインビジョン声明文\">ドメインビジョン声明文</h3>\n<p>コアドメインとそれがもたらす価値に関する簡潔な記述を作成することで、「価値の提議」を行える。\nドメインモデルがどのように役立ち、対象のアクターに対してそれぞれどのような対応を行うかを示す。\nスコープはコンテキスト内のスコープに限定する。\nこの声明文はプロジェクトの早期に作成し、新しい洞察を得たら都度改訂すること。</p>\n<h3 id=\"強調されたコア\">強調されたコア</h3>\n<p>ドメインビジョン声明文は広い観点から見た提議であり、具体性に乏しい。\n開発者にとってコアドメインはドメインビジョン声明文のような抽象的な状態で言語化されているだけでは十分ではない。\nそこで、コアドメインとコアを構成する要素感の主要な相互作用を記述した <strong>蒸留ドキュメント</strong> を記載する。</p>\n<h3 id=\"隔離されたコア\">隔離されたコア</h3>\n<p>コアドメインは洗練され、独立している状態にある必要がある。\nこのためには如何様な開発コストも割くべきである。</p>\n<h3 id=\"抽象化されたコア\">抽象化されたコア</h3>\n<p>モデルにおける最も根本的な概念を抽出し、それを抽象クラスやインタフェースにくくり出す。\nコアドメインを洗練できたとしても、膨大な詳細に圧倒されるような設計では理解することは難しい。\n抽象化の層を挟むことで階層的に理解が進むようになる。</p>\n<h2 id=\"大規模な構造\">大規模な構造</h2>\n<h3 id=\"責務のレイヤ\">責務のレイヤ</h3>\n<p>モデル間の概念状の依存関係、ドメインの様々な部分の変更の大きさと頻度を元に、ドメインの自然な階層を探す。\n階層に従い、抽象的な責務を割り当てる。\n概念的依存関係として下表のような金融システムの例をあげる。</p>\n<p>| レイヤ | 概念 | 状態 | 具体例 |\n| ---- | ---- | ---- | ---- |\n| 意思決定 | 分析メカニズム | 状態変化はほとんどない | リスク分析、交渉ツール |\n| ポリシー | 戦略、制約 | 遅い状態変化 | 準備金の限度、資産配分目標 |\n| 確約 ｜ビジネス取引と顧客の契約 | ボチボチな状態変化 | 顧客合意、シンジケート合意 |\n| 業務 | ビジネスの現実 | 早い状態変化 | 未払いローンの状態、支払いと配分 |</p>\n<h3 id=\"知識レベル\">知識レベル</h3>\n<p>エンティティ間にある役割と関係が状況によって変わるアプリケーションでは複雑さがます。\n例えば従業員とその役割などが当てはまる。\nリフレクションパターンにおけるベースモデルを業務レベル、メタレベルを知識レベルとすることで\nドメインモデルに適用したものを使うと複雑さを軽減できる。</p>","ogImage":{"url":"/assets/blog/dynamic-routing/cover.jpg"},"coverImage":"/assets/blog/dynamic-routing/cover.jpg"}},"__N_SSG":true}